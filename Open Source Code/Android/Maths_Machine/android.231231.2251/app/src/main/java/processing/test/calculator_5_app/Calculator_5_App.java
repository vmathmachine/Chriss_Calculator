package processing.test.calculator_5_app;

/* autogenerated by Processing revision 1292 on 2023-06-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Iterator;
import java.util.Stack;
import complexnumbers.*;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Intent;
import android.content.Context;
import android.app.Activity;
import android.os.Looper;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Calculator_5_App extends PApplet {



//import processing.sound.*;


/*import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.Toolkit;*/

/*
Android todo list:
change complexnumbers import
change size()
uncomment updateCursorsAndroid, in both tabs
comment updatePanelScroll in main tab
comment mouseWheel/mousePressed/mouseReleased/mouseMoved/mouseDragged
comment/uncomment BACKSPACE & ENTER stuff for keyPressed
comment/uncomment clear() code for Buffer.beginDraw()
make button to open keyboard
change text cursor thickness
change promoteDist to 64
change buffer limit to 128
*/

Mmio io;

boolean doubleTimes=false, doubleE=false, doubleDot=false, doubleX=false;
byte clearTimes = 0;

boolean saveWorks = true;

//static long init;

static Panel historyShow, equatHolder, equatList, keyPad; //panel to show history, to hold the list of equations, to list out the equations, and to show the keypad
Textbox inputField; //input field in calculator mode
ArrayList<Graphable> plots = new ArrayList<Graphable>(); //all the plots to be graphed out
ArrayList<String[]> cancels = new ArrayList<String[]>(); //backups of what the equations were last time we saved, just in case we want to cancel

Textbox equationColor;
Textbox equationCache; //When we change the color of the equation, we need to store the equation so we know to go back to it

Graph grapher;

GraphMode keypadMode = GraphMode.NONE; //this helps us identify which variables need to be available on the keypad

public void setup() {
  /* size commented out by preprocessor */;
  
  io = new Mmio(this);
  //io.cursors.add(new Cursor(mouseX,mouseY)); //PC only
  androidInitClipboard(this); //Android only
  interfaceInit(io);
  
  grapher = new Graph(width/2.0f,height/2.0f,height/12.0f).setVisible(false);
  
  if(saveWorks) { //if saving works
    loadHistory(); //load history from file
    loadEquations(); //load graphs from file
  }
  
  //init = System.currentTimeMillis();
}

public void draw() {
  background(0);
  
  //println("Frame Start: "+(System.currentTimeMillis()-init)/16.7);
  io.updateCursorsAndroid(touches); //Android only, records all changes in the touches[] array and updates accordingly
  //io.updatePanelScroll(io.cursors.get(0)); //PC only, records all updates in the mouseWheel and updates accordingly
  io.updatePanelDrag();
  io.targetAllChildren();
  grapher.updateFromTouches(io,0,0.05555556f*height);
  //println((System.currentTimeMillis()-init)/16.7);
  
  
  grapher.display(g,0,0.0555556f*height,width,0.94444444f*height,plots); //display graph
  
  io.display(); //display user interface
  
  //println("Display: "+(System.currentTimeMillis()-init)/16.7);
  
  io.wheelEventX = io.wheelEventY = 0;
  io.bufferGarbageCollect(); //garbage collect unused buffers
  io.updateCursorDPos();     //update previous draw positions (ALWAYS DO THIS AT THE END)
  
  //if(frameCount%30 == 1) { println(frameRate); } //DEBUG
}

/*void mouseWheel(MouseEvent event) {
  if(io.shiftHeld) { io.wheelEventX = event.getCount(); }
  else             { io.wheelEventY = event.getCount(); }
}

void mousePressed() {
  Cursor curs = io.cursors.get(0); //PC: there's only one cursor
  
  if(curs.press==0) { //if the cursor was previously not pressed
    io.setCursorSelect(curs); //set the cursor select to whatever it's selecting
  }
  
  curs.press(mouseButton); //press the correct button
  
  io.updateButtons(curs, (byte)1, false); //update the buttons, with code 1 for pressing
}

void mouseReleased() {
  Cursor curs = io.cursors.get(0); //PC: there's only one cursor
  curs.release(mouseButton); //release the correct button
  
  io.updateButtons(curs, (byte)0, false); //update the buttons, with code 0 for releasing
  //TODO make this compatible with multiple mouse buttons being pressed & released
  
  if(curs.press==0) { //if cursor isn't pressing anymore
    curs.setSelect(null); //set select for the just-released cursor to null
  }
}

void mouseMoved() {
  Cursor curs = io.cursors.get(0); //PC: there's only one cursor
  curs.updatePos(mouseX,mouseY);   //change the cursor position
  
  io.updateButtons(curs, (byte)2, false); //update the buttons, with code 2 for moving
}

void mouseDragged() {
  Cursor curs = io.cursors.get(0); //PC: there's only one cursor
  curs.updatePos(mouseX,mouseY);   //change the cursor position
  
  Mmio.attemptSelectPromotion(curs); //attempt select promotion
  io.updateButtons(curs, (byte)3, false); //update the buttons, with code 3 for dragging
}*/

public void keyPressed() {
  if(io.typer!=null) {
    if(keyCode==66 && key==10) { hitEnter(); } else //Android only, since their enter button is fucked
    switch(key) {
      case CODED: switch(keyCode) {
        case LEFT: io.typer.readInput(InputCode.LEFT); break;
        case RIGHT: io.typer.readInput(InputCode.RIGHT); break;
        case 36: io.typer.readInput(InputCode.HOME); break; //home
        case 35: io.typer.readInput(InputCode.END); break; //end
        
        case BACKSPACE: io.typer.readInput(InputCode.BACKSPACE); break; //(Android only) Backspace is a keyCode rather than a key. Also DELETE is the same as BACKSPACE
        
        case SHIFT: io.shiftHeld=true; break;
        
        //case 155: io.typer.insert^=true; break; //insert/overtype
      } break;
      //case DELETE: io.typer.readInput(InputCode.DELETE); break;
      //case BACKSPACE: io.typer.readInput(InputCode.BACKSPACE); break;
      //case ENTER: case RETURN: hitEnter(); break;
      
      case 'a'-96: break; //ctrl+A
      case 'c'-96: break; //ctrl+C
      case 'v'-96: { //ctrl+V
        String text = getTextFromClipboard();
        if(text!=null) { io.typer.readInput(new int[] {'I',0,'S',text.length()}, new String[] {text}); }
      } break;
      case 'x'-96: break; //ctrl+X
      case 'y'-96: break; //ctrl+y
      case 'z'-96: break; //ctrl+z
      
      default:
        io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE,new char[] {key});
      break;
    }
    disableTestVars();
  }
  
  if(key==CODED && keyCode==SHIFT) { io.shiftHeld = true; } //if the shift key is held down, shiftHeld becomes true
  
  //println("Key event:", key, int(key), keyCode);
}

public void keyReleased() {
  if(key==CODED) {
    if(keyCode==SHIFT) { io.shiftHeld=false; }
    else if(io.typer!=null && keyCode==155) { io.typer.insert^=true; }
  }
  
  if(key==CODED && keyCode==SHIFT) { io.shiftHeld=false; }
}




public Action typeAction2(final InputCode inp) { return new Action() { public void act() { if(io.typer!=null) { io.typer.readInput(inp); disableTestVars(); } } }; }

public Action typeAnsPrefix(final char inp) { return new Action() { public void act() { if(io.typer!=null) {
  if(io.typer==inputField && io.typer.size()==0) { io.typer.readInput(new int[] {'I',0,'S',4},new String[] {"Ans"+inp}); }
  else { io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {inp}); }
  disableTestVars();
} } }; }

public void disableTestVars() { doubleTimes=doubleE=doubleDot=doubleX=false; clearTimes=0; }
public static class Box {
  
  //////////////// ATTRIBUTES ///////////////
  
  //spatial attributes
  float x=0, y=0; //position WRT parent's surface (or to screen if no parent)
  float w=0, h=0; //width & height
  float r=0;      //corner radius
  
  //drawing attributes
  boolean fill=true, stroke=true; //whether it fills & has a stroke
  float strokeWeight=1;           //stroke weight
  int fillColor, strokeColor;   //fill & stroke color
  
  //other display attributes
  Text[] text = new Text[0]; //the text(s) we display on the box (empty by default)
  PImage image;              //the image to draw (null by default) TODO add this
  
  //parent
  Panel parent; //the panel this is inside of
  Mmio mmio;    //the ancestor panel everything is inside of
  
  //other attributes
  boolean mobile = true; //if true, the box moves with its parent's surface. If false, it stays glued to its parent's window
  boolean active = true; //if active, the box will be displayed and carry out all its duties. If not, it gets ignored until it is active again
  
  //////////////// CONSTRUCTORS ///////////////
  
  Box() { } //default constructor
  
  Box(final float x2, final float y2) { x=x2; y=y2; } //constructor w/ position
  
  Box(final float x2, final float y2, final float w2, final float h2) { //constructor w/ dimensions
    x=x2; y=y2; w=w2; h=h2; //set attributes
  }
  
  Box(final float x2, final float y2, final float w2, final float h2, final float r2) { //constructor w/ full dimensions
    this(x2,y2,w2,h2); r=r2; //set attributes
  }
  
  //////////////// GETTERS ////////////////
  
  public float getX() { return !mobile || parent==null ? x : x+parent.getSurfaceX(); } //get x position WRT parent
  public float getY() { return !mobile || parent==null ? y : y+parent.getSurfaceY(); } //get y position WRT parent
  
  public float getObjX() { return parent==null ? x : x+(mobile ? parent.getObjSurfaceX() : parent.getObjX()); } //get x position on screen (obj=objective)
  public float getObjY() { return parent==null ? y : y+(mobile ? parent.getObjSurfaceY() : parent.getObjY()); } //get y position on screen
  
  public float getWidth () { return w; } //get width
  public float getHeight() { return h; } //get height
  public float getRadius() { return r; } //get radius
  
  public Panel getParent() { return parent; } //get parent
  
  public boolean   fills() { return   fill; } //get whether it fills
  public boolean strokes() { return stroke; } //get whether it strokes
  public float getStrokeWeight() { return strokeWeight; } //get strokeWeight
  public int getFillColor   () { return    fillColor; } //get fill color
  public int getStrokeColor () { return  strokeColor; } //get stroke color
  
  //////////////// SETTERS ////////////////
  
  public Box setX(final float x2) { x=x2; return this; } //set x
  public Box setY(final float y2) { y=y2; return this; } //set y
  public Box setW(final float w2) { w=w2; return this; } //set width
  public Box setH(final float h2) { h=h2; return this; } //set height
  public Box setR(final float r2) { r=r2; return this; } //set radius
  public Box setPos(final float x2, final float y2) { x=x2; y=y2; return this; }
  public Box setDims(final float w2, final float h2) { w=w2; h=h2; return this; }
  
  public Box setParent(final Panel p) { //set parent
    if(parent==p) { return this; } //if same parent, do nothing
    
    if(parent!=null) { parent.children.remove(this); } //if currently has a parent, estrange
    if(p!=null) { p.children.add(this); mmio=p.mmio; } //if will have parent, join family
    parent=p;                                          //set parent
    
    return this; //return result
  }
  
  public Box setFill        (final boolean f) {         fill=f; return this; }
  public Box setStroke      (final boolean s) {       stroke=s; return this; }
  public Box setStrokeWeight(final   float s) { strokeWeight=s; return this; }
  
  public Box setFill  (final int f) { fillColor  =f; return this; } //set fill color
  public Box setStroke(final int s) { strokeColor=s; return this; } //set stroke color
  
  public Box setPalette(final Box b) { //copies over all of its color & draw attributes
    fill = b.fill; stroke = b.stroke; //copy whether it has fill/stroke
    strokeWeight = b.strokeWeight;    //copy its stroke weight
    fillColor = b.fillColor; strokeColor = b.strokeColor; //copy its fill & stroke color
    return this; //return result
  }
  
  public Box setShape(final Box b) { //copies over the exact shape
    w = b.w; h = b.h; r = b.r; //set the width, height, & radius
    return this;               //return result
  }
  
  public Box setText(Text... texts) { //sets the texts
    text = new Text[texts.length]; //initialize array
    for(int n=0;n<texts.length;n++) { text[n] = texts[n]; } //set each element
    return this; //return result
  }
  
  public Box setText(String txt, float siz, int col) {
    this.setText(new Text(txt,0.5f*w,0.5f*h,siz,col,CENTER,CENTER));
    return this;
  }
  
  public Box setText(String txt, int col) {
    float wid = mmio.getTextWidth(txt,32); int lines = Mmio.getLines(txt);
    float siz = min(32*(w-2*Mmio.xBuff)/wid, ((h-2*Mmio.yBuff)/lines-0.902f)/1.164f);
    this.setText(txt,siz,col);
    return this;
  }
  
  public Box setText(String txt, int col, float buffX, float buffY) {
    float wid = mmio.getTextWidth(txt,32); int lines = Mmio.getLines(txt);
    float siz = min(32*(w-2*buffX)/wid, ((h-2*buffY)/lines-0.902f)/1.164f);
    this.setText(txt,siz,col);
    return this;
  }
  
  public Box setMobile(final boolean m) { mobile=m; return this; }
  
  public Box setActive(final boolean a) { active=a; return this; }
  
  ////////////////////////////// DRAWING/DISPLAY //////////////////////////////////
  
  public void display(final PGraphics graph, float buffX, float buffY) { //displays on a particular PGraphics (whose top left corner is at buffX, buffY on the parent)
    //float x3 = getObjX()-x2, y3 = getObjY()-y2; //get location where you should actually draw
    float x3 = getX()-buffX, y3 = getY()-buffY; //get location where you should actually draw
    setDrawingParams(graph);                    //set drawing parameters
    graph.rect(x3,y3,w,h,r);                    //draw rectangle
    
    for(Text t : text) { //loop through all the texts
      t.display(graph,-x3,-y3); //draw them all
    }
  }
  
  public void setDrawingParams(final PGraphics graph) {
    if(fill) { graph.fill(fillColor); } else { graph.noFill(); }
    if(stroke) { graph.stroke(strokeColor); graph.strokeWeight(strokeWeight); } else { graph.noStroke(); }
  }
  
  
  ////////////////////////// HITBOX ///////////////////////////////////
  
  protected boolean hitboxNoCheck(final float x2, final float y2) {
    final float x3=x2-getObjX(), y3=y2-getObjY();      //get position relative to top left corner
    return active && x3>=0 && y3>=0 && x3<=w && y3<=h; //determine if it's within the bounding box
  }
  
  protected boolean hitboxNoCheck(final Cursor curs) { return hitboxNoCheck(curs.x,curs.y); }
  
  public boolean hitbox(final float x2, final float y2) {
    return (parent==null || parent.hitbox(x2,y2)) && hitboxNoCheck(x2,y2);
  } //if not in parent's hitbox, automatic false. Otherwise, check hitbox
  
  public boolean hitbox(final Cursor curs) { return hitbox(curs.x,curs.y); }
}

static class Text {
  String text; //text
  float x, y;  //text position
  float size;  //text size
  int fill;  //text color
  int alignX, alignY; //text alignment
  
  Text(String txt, float x2, float y2, float siz, int col, int alx, int aly) { //constructor w/ attributes
    text = txt; x=x2; y=y2; size=siz; fill=col; alignX=alx; alignY=aly;
  }
  
  /*@Override
  public Text clone() {
    return new Text(text,x,y,size,fill,alignX,alignY);
  }
  
  @Override
  public boolean equals(final Object obj) {
    if(!(obj instanceof Text)) { return false; }
    Text txt = (Text)obj;
    return text.equals(txt.text) && size==txt.size && fill==txt.fill;
  }
  
  @Override
  public int hashCode() { return 961*fill+31*Float.floatToIntBits(size)+text.hashCode(); }*/
  
  //TODO see if these /|\ are necessary. They probably aren't
  
  @Override
  public String toString() { return text; } //string is the string
  
  public String getText() { return text; } //text is the text
  
  public void display(final PGraphics graph, float buffX, float buffY) {    //displays itself onto the pgraphics, assuming the pgraphics is at position buffX,buffY WRT the parent
    graph.fill(fill); graph.textSize(size); graph.textAlign(alignX,alignY); //set drawing parameters
    graph.text(text,x-buffX,y-buffY);                                       //draw
  }
  
  
  
}

//clone, equals, hashCode, toString

//BOOL: fill, stroke
//FLOAT: strokeWeight, textSize
//COLOR: fillColor, strokeColor
//INT: textAlign, textAlignY
static class Buffer {
  
  ////////////// ATTRIBUTES /////////////////////////
  
  PGraphics graph;        //PGraphics object to load pixels onto
  boolean inUse   =false; //whether it's currently in use
  boolean canWrite=false; //whether the PGraphics is writeable
  byte usage=0;           //a record of whether is was used in the last 8 garbage collection cycles
  
  //////////////// CONSTRUCTORS //////////////////////
  
  Buffer(PApplet app, int w, int h) {
    graph = app.createGraphics(w,h); //load graphics buffer
  }
  
  ///////////////// GETTERS ////////////////////////
  
  public PGraphics getGraphics() { return graph; }
  public boolean isInUse() { return inUse; }
  public byte getUsage() { return usage; }
  public int width() { return graph.width; }
  public int height() { return graph.height; }
  
  public boolean wasUsed() { return usage!=0; } //returns whether it was used in the past 8 seconds
  
  /////////////// SETTERS ///////////////////////////
  
  public void stamp() { usage|=1; } //stamps to show it's been used
  public void step() { usage<<=1; } //takes 1 step: shift bits of usage recorder
  
  public void use() { inUse=true; usage|=1; } //sets that it's in use
  public void beginDraw() { inUse=canWrite=true; usage|=1; graph.beginDraw(); //graph.clear();
    graph.loadPixels(); java.util.Arrays.fill(graph.pixels, 0x00FFFFFF); graph.updatePixels(); //for Android and Processing 2.0, since the clear function doesn't quite work for those two versions
  } //sets that it's in use AND starts editing PGraphics object (starting with clearing the background completely)
  public void endDraw()   { canWrite=false; graph.endDraw();  } //stops editing PGraphics object
  public void usent() { inUse=false; } //sets that it's no longer in use (usen't)
  
  
  ////////////////// TESTING ///////////////////////////
  
  public void selfTest() { graph.noFill(); graph.strokeWeight(3); graph.stroke(0xFFFF00FF); graph.rect(0,0,graph.width,graph.height); } //test to make sure the buffer's actually there
}
static enum State { DISABLED, DEAD, HOVER, PRESS }; //the 4 states a button can be in
//(disabled = greyed out, dead = not selected, hover = hovered over, press = being pressed

public static class Button extends Box {
  
  ///////////////////////// ATTRIBUTES /////////////////////////
  
  Action onPress   = emptyAction; //the functionality when pressed
  Action onRelease = emptyAction; //the functionality when released
  Action onHeld    = emptyAction; //the functionality when held down for a certain amount of time
  int holdTimer = 500; //how long you have to hold down in milliseconds (0.5 s by default)
  int holdFreq  = 100; //how frequently the hold functionality is repeatedly applied (technically, inverse frequency, 0.1s by default)
  
  ClickProgressor progress = new ClickProgressor(); //tracks how the user interacts with it
  
  boolean selectOnPress  =false , //if true, button only registers press if it was selected when you first clicked (if false, moving your mouse into the hitbox will always select it, so long as it's pressed and in button mode)
          selectOnRelease=true ; //if true, button only registers release if it was selected when you released it (if false, moving your mouse out of the hitbox won't deselect it)
  
  //example of button where select on press is false: most smartphone touch screen buttons, where you can press something, then move your cursor away as you realized you pressed the wrong button, then move your cursor back to the right button & press it
  //example of button where select on release is false: up and down arrows on a scroll bar. If you press those, then move your cursor, they stay pressed
  
  HashMap<Cursor, Boolean> cursors = new HashMap<Cursor, Boolean>(); //list of cursors that are pressing this button, as well as 1 boolean to represent if the button is being held down by this cursor
  
  
  
  //the 1s bit indicates it's hovered, 2s bit indicates it's pressed, and 4s bit indicates it's being held. 1 and 2 are mutually exclusive, while 4s bit implies 2s bit
  //the button is actually pressed if at least one entry is pressed. otherwise, it's hovered if at least one is hovered. otherwise, it's either disabled or dead
  //no entries will be dead because dead entries get removed
  
  ///////////////////////// CONSTRUCTORS /////////////////////////
  
  Button() { } //default constructor
  
  Button(final float x2, final float y2, final float w2, final float h2) { //constructor with parameters
    super(x2,y2,w2,h2); setTimings(Mmio.timing1,Mmio.timing2,Mmio.timing3);
  }
  
  Button(final float x2, final float y2, final float w2, final float h2, final float r2) { //constructor with parameters (and radius)
    super(x2,y2,w2,h2,r2); setTimings(Mmio.timing1,Mmio.timing2,Mmio.timing3);
  }
  
  ///////////////////////// GETTERS /////////////////////////
  
  
  
  ///////////////////////// SETTTERS /////////////////////////
  
  public Button setFills  (final int a, final int b, final int c) { progress.  fill.put(State.DEAD,a); progress.  fill.put(State.HOVER,b); progress.  fill.put(State.PRESS,c); return this; }
  public Button setStrokes(final int a, final int b, final int c) { progress.stroke.put(State.DEAD,a); progress.stroke.put(State.HOVER,b); progress.stroke.put(State.PRESS,c); return this; }
  public Button setTimings(final float a, final float b, final float c) { progress.duration.put(State.DEAD,round(1000*a)); progress.duration.put(State.HOVER,round(1000*b)); progress.duration.put(State.PRESS,round(1000*c)); return this; }
  
  public Button setFills  (final int a, final int c) { progress.  fill.put(State.DEAD,a); progress.  fill.put(State.HOVER,lerpColor(a,c,0.5f,RGB)); progress.  fill.put(State.PRESS,c); return this; }
  public Button setStrokes(final int a, final int c) { progress.stroke.put(State.DEAD,a); progress.stroke.put(State.HOVER,lerpColor(a,c,0.5f,RGB)); progress.stroke.put(State.PRESS,c); return this; }
  
  public Button setFills  (final int a) { progress.  fill.put(State.DEAD,a); progress.  fill.put(State.HOVER,a); progress.  fill.put(State.PRESS,a); return this; }
  public Button setStrokes(final int a) { progress.stroke.put(State.DEAD,a); progress.stroke.put(State.HOVER,a); progress.stroke.put(State.PRESS,a); return this; }
  
  public Button setStroke(final boolean s) { super.setStroke(s); if(!stroke) { setStrokes(0,0,0); } return this; }
  
  public Button setOnClick(final Action act) { onPress=act; return this; } //sets the behavior when clicked
  public Button setOnRelease(final Action act) { onRelease=act; return this; } //sets the behavior when released
  public Button setOnHeld(final Action act, final float... hold) { //sets the behavior when held down for a certain amount of time
    onHeld=act; //set hold down behavior
    if(hold.length>0) { holdTimer=round(1000*hold[0]); } //if specified, set how long it has to be held down
    return this; //return result
  }
  
  public Button setPalette(final Button b) { //sets the color palette to be a perfect match of the inputted button
    progress.fill   = (HashMap<State,Integer>)b.progress.  fill.clone(); //clone the fill values
    progress.stroke = (HashMap<State,Integer>)b.progress.stroke.clone(); //clone the stroke values
    stroke = b.stroke;             //set whether it even has a stroke
    strokeWeight = b.strokeWeight; //set its stroke weight
    return this;                   //return result
  }
  
  public Button setOnClickListener(final Action act) { return setOnClick(act); } //does the same thing as setOnClick, but given a different name for ease of use for those comfortable with android studio
  
  public Button disable() { progress.curr = State.DISABLED; return this; }
  public Button enable() { progress.curr = State.DEAD; return this; }
  
  ///////////////////////// DRAWING/DISPLAY /////////////////////////
  
  public void setDrawingParams(final PGraphics graph) {
    graph.fill(progress.getFill());
    if(stroke) { graph.strokeWeight(strokeWeight); graph.stroke(progress.getStroke()); } else { graph.noStroke(); }
  }
  
  
  //////////////////////// REACTORS ////////////////////////////////
  
  //returns whether the cursor is in its hitbox
  public boolean respondToChange(final Cursor curs, final byte code, boolean selected) { //responds to change in the cursor (code tells us what kind of change. 0=release, 1=press, 2=move, 3=drag) (select tells us if the cursor is already touching something)
    if(progress.curr==State.DISABLED) { return false; } //if disabled, do nothing
    
    boolean hitbox = hitbox(curs); //record whether the cursor is in this button
    
    if(cursors.get(curs) == null) { //if this cursor ISN'T pressing the button:
      if(hitbox && !selected) { //first, make sure the cursor is in the hitbox AND hasn't already selected something else
        if(code==1) {              //if the cursor just pressed:
          cursors.put(curs, true); //push this cursor to the list, with hold being true
          onPress.act();           //perform the onPress event
        }
        else if(curs.press!=0 && !selectOnPress && curs.select instanceof Button) { //otherwise, if the cursor is already pressed and in button-select mode, and we're allowed to do it this way:
          cursors.put(curs, false); //push this cursor to the list, with hold being false. Don't activate press functionality, it doesn't apply for this case
        }
      }
    }
    
    else { //if this cursor IS pressing the button:
      if(code==0) { //if the cursor is just released:
        onRelease.act();      //perform the onRelease event
        cursors.remove(curs); //remove this cursor from the list
      }
      else if((code&2)==2 && selectOnRelease && !hitbox) { //otherwise, if the cursor just left the hitbox, and leaving makes it deactivate
        cursors.remove(curs); //remove this cursor from the list
      }
      //TODO see if we should even bother checking the code&2, since it just tells us if the mouse moved. Which, I'm pretty sure was just a shortcut to see if we had to check the hitbox, which has already been calculated
    }
    
    //finally, use the updated information to update the click progressor:
    updateProgressor();
    
    //TODO implement the press & hold feature
    //TODO make it so different mouse buttons can do different things
    return hitbox;
  }
  //potential brainbending glitch: what happens if you do something with a button, then it disappears? Like, you scroll away and can no longer see it?
  
  
  public void updateProgressor() { //updates the click progressor
    if(cursors.size()==0) { //if no cursors are pressing this button
      State swap = State.DEAD;       //the state we will swap to
      for(Cursor c : mmio.cursors) { //loop through all cursors
        if(hitbox(c)) { swap = State.HOVER; break; } //if at least one cursor is in the hitbox, swap to hover
      }
      progress.update(swap); //swap to that state
    }
    else { progress.update(State.PRESS); } //if at least one cursor is pressing this button, swap to the pressed state
  }
}

interface Action { void act(); }

static Action emptyAction = new Action() { public void act() { } }; //empty action

public Action typeAction(final InputCode inp) { return new Action() { public void act() { if(io.typer!=null) { io.typer.readInput(inp); } } }; }



static class ClickProgressor { //a class specifically dedicated to measuring and tracking the progress of the color change in a button
  
  /////////////////// ATTRIBUTES //////////////////////////
  
  State curr=State.DEAD; //current state
  long lastEvent;   //time of last event in milliseconds
  int lastFill;   //the color it was at the start of this
  int lastStroke; //same, but for stroke
  
  HashMap<State,Integer>     fill = new HashMap<State,Integer>(4); //the fill colors when not pressed, hovered over, and pressed
  HashMap<State,Integer>   stroke = new HashMap<State,Integer>(4); //the stroke colors when not pressed, hovered over, and pressed
  HashMap<State,Integer> duration = new HashMap<State,Integer>(4); //the time it takes to fully switch to a particular state
  
  //////////////////// CONSTRUCTORS //////////////////////
  
  ClickProgressor() {  }
  //TODO make this more privatized, if appropriate
  
  //////////////////// GETTERS ////////////////////////////
  
  private int getColor(int lastColor, HashMap<State, Integer> colorMap) {
    if(duration.get(curr)==0) { return colorMap.get(curr); } //if transition is instantaneous, return the current color
    
    long time = System.currentTimeMillis();                      //find the current time
    float progress = (time-lastEvent)/(float)duration.get(curr); //divide the time passed by the total time it takes
    progress = constrain(progress,0,1);                          //constrain to the range 0-1
    
    return lerpColor(lastColor,colorMap.get(curr),progress,RGB); //return the lerping between the two colors
  }
  
  public int getFill() { return getColor(lastFill, fill); } //gets current fill
  
  public int getStroke() { return getColor(lastStroke, stroke); } //gets current stroke
  
  //////////////////// PROGRESSION ///////////////////////
  
  public void update(final State state) { //initiates a new event & updates accordingly
    if(state==curr) { return; } //if this state is exactly the same as the old state, DO NOTHING
    
    lastFill = getFill(); lastStroke = getStroke(); //update the initial stroke and fill
    lastEvent = System.currentTimeMillis();         //set the time of the event
    curr = state;                                   //lastly, update the state
  }
}
public static class Cpx3 extends Cpx2 {
  public static Complex polygamma2(int m, Complex z) {
    if(m==-2) { return kFunction(z,false).addeq(mul(sub(Math.log(2*Math.PI)+1,z),z,0.5f)); }
    return polygamma(m,z);
  }
  
  public static Complex kFunction(Complex a, boolean expo) { //K-Function
    
    if(a.equals(0)) { return one(); } //special case a==0: return 1
    
    Complex z=a.re>=0 ? a.add(5) : sub(6,a); //either perform the K-Function 5 steps ahead & work backwards, or do the same thing for 1-a & use a reflection formula
    
    Complex expon=mul(z,z.sub(1),0.5f).addeq(1.0D/12).muleq(ln(z)).subeq(sq(z.mul(0.5f))); //initialize our exponent
    
    Complex iter=sq(z.inv()); //this is what the term will multiply by each time
    Complex term=iter.copy(); //this'll store z^(-2k+2)
    
    for(int k=2;k<8;k++) {
      expon.subeq(term.mul(Bernoulli[k<<1]/(4*k*(2*k-1)*(k-1)))); //add each term
      term.muleq(iter); //multiply by the iterator
    }
    
    for(int n=1;n<=5;n++) { //loop through the five numbers right before z, and subtract said numbers times their natural log
      expon.subeq(ln(z.sub(n)).muleq(z.sub(n)));
    }
    
    if(a.re<0) { //if a is less than 0, apply the (very intricate) reflection formula
      expon.addeq(Cl2(a.mul(2*Math.PI)).div(2*Math.PI)); //for starters, the exponent has to add a scaled version of the clausen function

      Complex reflector=a.mul(sub(1,a));        //this is our reflector.  It will either be added or subtracted from our answer, depending on the imaginary part
      Complex b=a.sub(Math.ceil(a.re));         //I'll be honest, I don't fully understand how this reflection works, I mostly just used trial and error on a very exception-heavy problem
      reflector.addeq(b.mul(b.add(1)));
      reflector.muleqI(HALFPI);
      if(a.im<0) { expon.addeq(reflector); } //if the imaginary part is negative, add the reflector
      else       { expon.subeq(reflector); } //if it's positive or 0, subtract the reflector
    }
    
    expon.re+=0.2487544770337843D; //add the log of the Glaisher-Kinkelin constant
    
    return expo ? exp(expon) : expon; //return the natural exponent of our result (unless we want the log-K function)
  }
  
  public static Complex barnesG(Complex z) { //returns the Barnes G-Function of z
    if(z.isInt() && z.re<=0) { return zero(); }                       //special case z is non-positive integer: return 0
    return exp(sub(z,1).muleq(loggamma(z))).diveq(kFunction(z,true)); //G(z)=Γ(z)^(z-1)/K(z)
  }
  
  ////////////////////////////// ZETA FUNCTIONS ///////////////////////////
  
  public static Complex zeta(Complex s) {
    if(Math.abs(s.im)>30 && s.re>-4 && s.re<5) { return zeta2(s); }
    else                                       { return zeta1(s); }
  }
  
  private static Complex zeta1(Complex s) {
    
    if(s.re<0.5f) {
      if(Math.abs(s.im)>300) { return exp(s.sub(1).mul(Math.log(2*Math.PI)).add(s.mulI().abs2().mul(HALFPI)).add(loggamma(sub(1,s)))).mul(zeta1(sub(1,s))).mulI(csgn(s.im)); }
      return mul(pow(complex(2*Math.PI),s),sin(s.mul(HALFPI)),gamma(sub(1,s))) .mul(zeta1(sub(1,s))).div(Math.PI);
    }
    
    double[] coef={1.0D, -1.0D, 1.0D, -1.0D, 1.0D, -0.9999999999999956D, 0.9999999999997994D, -0.9999999999938609D, 0.9999999998649105D, -0.9999999977694676D,
            0.9999999714737119D, -0.9999997104537386D, 0.9999976222939507D, -0.9999839584657739D, 0.999909963580878D, -0.9995752248158726D, 0.998300908965645D, -0.9941953510449523D, 0.9829544651872266D, -0.9567257315192D,
            0.9044921225074828D, -0.8156949871875634D, 0.6869855506262866D, -0.5283436869577361D, 0.36280435095577035D, -0.21751716776255578D, 0.11124997091266166D, -0.04729731398489733D, 0.016192457785229986D, -0.004275662228214578D,
            8.152497252699953E-4D, -9.970680093230158E-5D, 5.86510593719421E-6D};
    
    Complex sum=zero();
    for(int n=1;n<=coef.length;n++) {
      sum.addeq(mul(pow(new Complex(n),s.neg()),coef[n-1]));
    }
    
    return div(sum,sub(1,pow(complex(2),sub(1,s))));
  }
  
  private static Complex zeta2(Complex s) {
    Complex t=sub(0.5f,s).muleqI();
    int m=(int)Math.floor(sqrt(t.mul(csgn(s.im)/(2*Math.PI))).re);
    
    Complex theta=rsTheta(s.sub(0.5f).diveqI()); //compute the Riemann-Siegel Theta Function
    
    Complex sum=(m==0?zero():cos(theta));
    for(int k=2;k<=m;k++) {
      sum.addeq( cos(theta.sub(t.mul(Math.log(k)))).diveq(Math.sqrt(k)) );
    }
    sum.muleq(2);
    
    Complex sum2=zero();
    Complex term=one();
    Complex iter=sqrt(div(2*Math.PI*csgn(s.im),t));
    Complex inp=iter.inv().subeq(m).muleq(2).subeq(1);
    
    double[] coef={0.5D,0.5D,1.2337005501361697D,1.2337005501361697D,0.41576387242884216D,-17.571264781494055D,-89.76409950303267D,-348.55262483408745D,-764.3879449480118D,1784.5561668662722D,29190.148401564962D,202565.10667286662D,814080.3882205525D,
            974030.8878581069D,-1.957849534898767E7D,-2.2459951712568212E8D,-1.390261988148928E9D,-4.633697498894301E9D,1.6887987043774656E10D,4.036267034527721E11D,3.580901293164045E12D,1.8567163359058586E13D,6.489660305505916E12D,
            -1.0340517738538868E15D,-1.3024983661929054E16D,-9.2205787899349568E16D,-2.57539235105429344E17D,3.3255537896359675E18D,6.3351064269818356E19D,5.831853872469764E20D,2.7815735241170354E21D,-1.064709072231034E22D};
    Complex[] deriv=new Complex[19];
    Complex termd=one(), iterd=inp.abs2().sub(0.5f);
    //if(testmessage) { println(iterd); }
    for(int n=0;n<19;n++) if(n!=13 && n!=16 && n!=17) { deriv[n]=zero(); }
    for(int n2=0;n2<coef.length;n2++) {
      for(int n=0;n<19;n++) if(n!=13 && n!=16 && n!=17 && n<coef.length-n2) {
        deriv[n].addeq(termd.mul(coef[n2+n]));
      }
      termd.muleq(iterd.div(n2+1));
    }
    if(!inp.isRoot()) { for(int n=1;n<17;n+=2) if(n!=13) { deriv[n].negeq(); } }
    
    
    Complex[] out={deriv[0], deriv[3].div(-12*Math.PI*Math.PI), deriv[2].div(16*Math.PI*Math.PI).add(deriv[6].div(288*pow(Math.PI,4))), deriv[1].div(-32*Math.PI*Math.PI).sub(deriv[5].div(120*pow(Math.PI,4))).sub(deriv[9].div(10368*pow(Math.PI,6)))
            ,deriv[0].mul(143/(18432*Math.PI*Math.PI)).add(deriv[4].mul(19/(1536*pow(Math.PI,4)))).add(deriv[8].mul(11/(23040*pow(Math.PI,6)))).add(deriv[12].div(497664*pow(Math.PI,8)))
            ,deriv[3].mul(-2879/(221184*pow(Math.PI,4))).sub(deriv[7].mul(901/(645120*pow(Math.PI,6)))).sub(deriv[11].mul(7/(414720*pow(Math.PI,8)))).sub(deriv[15].div(29859840*pow(Math.PI,10)))
            ,deriv[2].mul(2879/(294912*pow(Math.PI,4))).add(deriv[5].mul(79267/(26542080*pow(Math.PI,6)))).add(deriv[10].mul(18889/(232243200*pow(Math.PI,8)))).add(deriv[14].mul(17/(39813120*pow(Math.PI,10)))).add(deriv[18].div(2149908480L*pow(Math.PI,12)))
    };
    
    for(int n=0;n<out.length;n++) {
      sum2.addeq(term.mul(out[n]));
      term.muleq(iter);
    }
    sum2.muleq(sqrt(iter));
    
    if((m&1)==0) { sum.subeq(sum2); }
    else         { sum.addeq(sum2); }
    
    sum.muleq(exp(theta.divI()));
    
    return sum;
  }
  
  public static Complex rsTheta(Complex t) { //returns the Riemann-Siegel Theta function
    
    Complex s=t.mulI().addeq(0.5f);
    
    Complex theta=sub(Math.log(Math.PI),s.mul(Math.log(2*Math.PI)).add(loggamma(sub(1,s))));
    if(Math.abs(s.im)>400) { theta.subeq(s.mulI(HALFPI).abs2().subeq(new Complex(LOG2,-HALFPI*csgn(s.im))));                                    }
    else                   { theta.subeq(ln(sin(s.mul(HALFPI)))).subeq(iTimes(2*Math.PI*csgn(s.re*s.im)*Math.round(0.25f*csgn(s.re)*(1-s.re)))); }
    theta.muleqI(-0.5f);
    if(t.im==0) { theta.im=0; }
    
    return theta;
  }
  
  public static Complex rsZFunction(Complex t) { //returns the Riemann-Siegel Z Function
    
    Complex s=t.mulI().addeq(0.5f);
    Complex res=zeta(s).muleq(exp(rsTheta(t).muleqI())); //compute the result
    if(t.im==0) { res.im=0; }
    return res;
  }
  
  ///////////////////////////// POLYLOGARITHMS ////////////////////////////
  
  public static Complex Li2(Complex z) { return polylog(2,z); } //dilogarithm of complex input z
  
  public static Complex Cl2(Complex z) { //returns the clausen function of complex z
    if(z.im==0) { return new Complex(Li2(exp(iTimes(z.re))).im); } //if a is real, return the imaginary part of Li2(e^(ai))
    return Li2(exp(z.mulI())).sub(Li2(exp(z.divI()))).mulI(-0.5D); //otherwise, return (Li2(e^(ai))-Li2(e^(-ai)))/(2i)
  }
  
  private static Complex powPolylog(int s, Complex z, int iters) { //computes the polylogarithm via a power series
    if(absq(z)>1) {
      Complex reflector=bernPoly(s,ln(z.neg()).muleqI(-1.0D/(2*Math.PI)).addeq(0.5f)).muleq(pow(iTimes(2*Math.PI),s).negeq());
      if(z.im==0 && z.re>0 && z.re<1) {
        reflector.addeq(pow(ln(z),s-1).muleqI(2*Math.PI*s));
      }
      double fact=1.0D;
      for(long k=1;k<=s;k++) { fact*=k; }
      reflector.diveq(fact);
      if((s&1)==0) { return reflector.subeq(powPolylog(s,z.inv(),iters)); }
      else         { return reflector.addeq(powPolylog(s,z.inv(),iters)); }
    }
    
    Complex sum=zero(), expo=z.copy();
    for(int n=1;n<=iters;n++) {
      sum.addeq(expo.div(pow(n,s)));
      expo.muleq(z);
    }
    
    return sum;
  }
  
  private static Complex logPolylog(int s, Complex lnz, int iters) { //computes polylogarithm via a power series of the natural logarithm (plus an ln(-ln(z)) term)
    double[] zetaPos={-0.5D,INF,1.64493406684822644D,1.20205690315959429D,1.08232323371113819D,1.03692775514336993D,1.01734306198444914D,1.00834927738192283D,1.00407735619794434D,
            1.00200839282608221D,1.00099457512781808D,1.00049418860411946D,1.00024608655330804D,1.00012271334757848D,1.00006124813505870D,1.00003058823630702D,1.00001528225940865D};
    double[] zetaNeg={-0.5D,-1.0D/12,0,1.0D/120,0,-1.0D/252,0,1.0D/240,0,-1.0D/132,0,691.0D/32760,0,-1.0D/12,0,3617.0D/8160,0,-43867.0D/14364,0,174611.0D/6600,0,-77683.0D/276,0,
            236364091.0D/65520,0,-657931.0D/12,0,3392780147.0D/3480,0,-1723168255201.0D/85932,0,7709321041217.0D/16320,0,-151628697551.0D/12,0,26315271553053477373.0D/6909840,
            0,-154210205991661.0D/12};
    //create arrays to store precomputed values for the zeta function at particular points
    
    Complex sum=zero(), expo=one(), iter=lnz.copy(); //init sum, exponent, and iterator
    
    for(int n=0;n<s-1;n++) { //compute Σ[n=0,s-2] ζ(s-n)ln(z)^n/n!
      if(s-n>16) {
        double zetaapprox=1;
        for(int k=2;k<=10;k++) { zetaapprox+=pow(k,-s); }
        sum.addeq(expo.mul(zetaapprox));
      }
      else { sum.addeq(expo.mul(zetaPos[s-n])); }
      expo.muleq(iter).diveq(n+1);
    }
    
    if(!iter.equals(0)) { //this term can only be added if lnz!=0 (otherwise, we get lim(x→0) xln(x) = 0)
      double Harmon=0.0D;
      for(int n=1;n<s;n++) { Harmon+=1.0D/n; }
      sum.addeq(sub(Harmon,ln(iter.neg())).muleq(expo)); //add ln(z)^(s-1)/(s-1)!*(Σ[n=1,s-1]1/n - ln(-ln(z)))
    }
    expo.muleq(iter).diveq(s); //exponent := ln(z)^s/s!
    
    sum.subeq(expo.mul(0.5D));   //subtract exponent/2
    expo.muleq(iter).diveq(s+1); //exponent := ln(z)^(s+1)/(s+1)!
    iter.muleq(iter);            //square the iterator
    
    for(int n=0;n<=iters-s;n++) { //add Σ[n=0,iters-s → ∞] ζ(2n+1)*ln(z)^(s+2n+1)/(s+2n+1)!
      sum.addeq(expo.mul(zetaNeg[2*n+1]));
      expo.muleq(iter).diveq((2*n+s+2)*(2*n+s+3));
    }
    
    return sum; //return summation
  }
  
  public static Complex polylog(int s, Complex z) { //computes the s-th polylogarithm of complex z
    
    if(s<2) { //if s<2, then we can compute the polylogarithm through explicit means
      if(s==1) { return ln(sub(1,z)).negeq(); } //Li1(z) = -ln(1-z)
      if(s==0) { return z.div(sub(1,z));      } //Li0(z) = z/(1-z)
      if(s<0) {                                 //for negative s, we take a power series, where each coefficient is found through a sum. (both sums are finite)
        Complex iter=z.div(sq(sub(1,z))); //iterator
        Complex expo=iter.copy();         //exponent = iter ^ k
        Complex sum=zero();               //sum
        double term_init=1;               //equals (-1)^(k-1) * (2k choose k+1) each iteration
        for(int k=1;k<=(1-s)>>1;k++) {    //perform power series
          double coef=0;                  //init coefficient to 0
          double term=term_init;          //term equals (-1)^(j-k) times (2k choose j+k)
          for(int j=1;j<=k;j++) {         //coef=Σ[j=1,k] (-1)^(j-k) * (2k choose j+k) * j^(2ceil(-s/2))
            coef+=term*pow(j,(~s&~1)+2);
            term*=(j-k)/(double)(j+k);
          }
          if((s&1)==1) { coef/=k; }                      //if s odd, divide by k
          sum.addeq(expo.mul(coef));                     //add coef * exponent
          expo.muleq(iter);                              //exponent mults by iterator
          term_init*=-(2*k+1)*(2*k+2)/(double)(k*(k+2));
        }
        if((s&1)==0) { sum.muleq(div(add(1,z),sub(1,z))); } //multiply by this thing if s is even
        return sum;                                         //return sum
      }
    }
    //approximate polylogarithm through a combination of the power series, log series, duplication formula, & reflection formula
    
    Complex u=ln(z), v=u.div(2*Math.PI);                      //u=ln(z), v=ln(z)/(2π)
    Complex lnneg=v.add(iTimes(0.5f*csgn(-v.im)));             //ln(-z)/(2π)
    Complex lnsq=v.mul(2).addeq(iTimes(Math.round(-2*v.im))); //ln(z²)/(2π)
    
    //"CONVergence", each # is proportional to the approx convergence time of each alg. If an alg never converges, the denom becomes negative, so
    //we use this max(0,#) trick to turn any negative denom to 0, to represent ∞ convergence time
    double[] conv={2.0D/Math.abs(u.re), 1.0D/Math.max(0,-ln(v).re), 1.0D/Math.max(0,-ln(lnsq).re), 1.0D/Math.max(0,-ln(lnneg).re)};
    
    conv[2]+=conv[3];     //we could initialize them all at once, but it's slightly faster this way
    conv[3]+=0.5f*conv[0];
    
    double mins=INF; //minimum convergence rate
    int best=-1;     //index of the best convergence rate
    
    for(int n=0;n<4;n++) if(conv[n]<mins) { mins=conv[n]; best=n; } //sequential search for minimum
    
    switch(best) {
      case 0 : return powPolylog(s,z,20);                       //alg 0: power series (combined w/ refl. formula for |z|>1)
      case 1 : return logPolylog(s,u,20);                       //alg 1: power series of ln(z) (plus an ln(-ln(z)) term)
      case 2 : return logPolylog(s,lnsq.mul(2*Math.PI),14).muleq(pow(2,1-s)).subeq(logPolylog(s,lnneg.mul(2*Math.PI),14)); //duplication formula w/ 2 log series
      default: return powPolylog(s,sq(z)              ,15).muleq(pow(2,1-s)).subeq(logPolylog(s,lnneg.mul(2*Math.PI),15)); //duplication formula w/ 1 power & 1 log series
    }
  }
  
  public static Complex bernPoly(int n, Complex z) { //computes the nth Bernoulli polynomial for Complex z
    if(n==0) { return one(); } //special case, n=0: return 1
    Complex sum=zero(), expo=((n&1)==0)?one():z.mul(n), iter=sq(z);
    for(int k=n&1;k<n-1;k++) {
      sum.addeq(expo.mul(Bernoulli[n-k]));
      expo.muleq(z).muleq(((double)(n-k))/(k+1));
    }
    sum.addeq(expo.mul(z.div(n).sub(0.5D)));
    return sum;
  }
  
  ///////////////////////////// EXPONENTIAL INTEGRALS ///////////////////////////
  
  public static Complex ein(Complex a) { //takes the (adjusted) Exponential integral of complex input a
    if((a.re-0.179D)*(a.re-0.179D)/598.487D+a.im*a.im/194.017D <= 1.0D) {
      Complex sum=zero();        //this is used to store a long summation
      Complex term=a.copy();     //this is used to store each term in the series
      Complex iter=a.mul(-0.5D); //this is what term will multiply by each time
      double sum2=1.0D;          //this will be used to store a sum within the sum
      
      for(int n=1;n<=40;n++) {
        sum.addeq(term.mul(sum2)); //add each term
        
        term.muleq(iter.div(n+1));         //multiply the term by the iterator
        if((n&1)==0) { sum2+=1.0D/(n+1); } //only if n is even, add 1/(n+1) to the nested sum
      }
      
      sum.muleq(exp(a.mul(0.5f)));          //multiply the sum by e^(a/2)
      return sum.add(GAMMA); //return the sum plus the mascheroni constant
    }
    
    else {
      double[][] coef={{1,-7.44437068161936701e2D, 1.96396372895146870e5D,-2.37750310125431834e7D, 1.43073403821274637e9D,-4.33736238870432523e10D, 6.40533830574022023e11D,-4.20968180571076940e12D, 1.00795182980368575e13D,-4.94816688199951963e12D, -4.94701168645415960e11D},
              {1,-7.46437068161927678e2D, 1.97865247031583951e5D,-2.41535670165126845e7D, 1.47478952192985465e9D,-4.58595115847765780e10D, 7.08501308149515402e11D,-5.06084464593475077e12D, 1.43468549171581016e13D,-1.11535493509914254e13D},
              {1,-8.13595201151686150e2D, 2.35239181626478200e5D,-3.12557570795778731e7D, 2.06297595146763354e9D,-6.83052205423625007e10D, 1.09049528450362786e12D,-7.57664583257834349e12D, 1.81004487464664575e13D,-6.43291613143049485e12D, -1.36517137670871689e12D},
              {1,-8.19595201151451564e2D, 2.40036752835578778e5D,-3.26026661647090822e7D, 2.23355543278099360e9D,-7.87465017341829930e10D, 1.39866710696414565e12D,-1.17164723371736605e13D, 4.01839087307656620e13D,-3.99653257887490811e13D}};
      
      Complex[] numden={zero(), zero(), zero(), zero()}; //these will give us the numerators and denominators of the f and g auxiliary functions
      
      Complex term, iter=sq(a.inv()); //term and iterator
      
      for(int m=0;m<4;m++) { //loop through all 4 entries in the numden array
        term=one();          //initialize term to 1
        for(double c: coef[m]) {        //loop through the coefficients
          numden[m].addeq(term.mul(c)); //add each term times the coefficient
          term.muleq(iter);             //multiply the term by the iterator
        }
      }
      
      Complex auxf=numden[0].div(numden[1].mul(a)), auxg=numden[2].div(numden[3]).mul(iter); //compute the auxiliary f and g functions
      
      Complex ret=add(auxf,auxg).mul(exp(a)); //this is what we will return
      if(a.im>0 || a.im==0 && a.re<0) { ret.im+=Math.PI; }
      else if(a.im<0)                 { ret.im-=Math.PI; }
      ret.subeq(ln(a)); //subtract the natural logarithm
      
      return ret; //return the result
    }
  }
  
  public static Complex trigInt(Complex a, boolean CorS) { //this takes either the Ci or Si of complex a
    Complex sample=ein(a.mulI()); //first, calculate the regularized Exponential integral of a*i
    
    if(a.im==0) { //if a is real:
      return new Complex(CorS ? sample.re : sample.im); //either return the real or imaginary part of the Ein, depending on if it's the Ci or Si function
    }
    
    if(CorS) { return sample.add(ein(a.divI())).mul(0.5f); } //Ci(x)=(Ein(xi)+Ein(-xi))/2
    return sample.sub(ein(a.divI())).mulI(-0.5D);           //Si(x)=(Ein(xi)-Ein(-xi))/(2i)
  }
  
  public static Complex auxInt(Complex a, boolean fOrg) { //this takes the auxiliary f or g function of  complex a
    if(fOrg) { return sub(HALFPI,trigInt(a,false)).mul(cos(a)).add(add(trigInt(a,true),ln(a),GAMMA).mul(sin(a))); }
    else     { return sub(HALFPI,trigInt(a,false)).mul(sin(a)).sub(add(trigInt(a,true),ln(a),GAMMA).mul(cos(a))); }
  }
  
  ///////////////////////////// ELLIPTIC INTEGRALS //////////////////////////////
  
  private static Complex[] AGM_method(Complex k, int type) { //this computes the AGM between k and 1.  If the type is 2, it also computes the derivative of the AGM
    if(k.equals(0)) { return new Complex[] {zero(),complex(-INF)}; } //special case: k==0, return 0 & -∞
    if(k.equals(1)) { return new Complex[] {one (),complex(0.5f) }; } //special case: k==1, return 0 & 1/2
    
    Complex a=one(), b=k.copy(), c=zero(), d=one(); //initialize a, b, c, & d to 1, k, 0, 1
    Complex b2, d2;                                 //declare b2 and d2 to store copies of b & d
    
    for(short n=0;n<8;n++) {  //loop through several iterations of the process below
      b2=b.copy();            //copy b
      b=sqrt(mul(a,b));       //set b=geometric mean
      if(type==2) {           //do this step only if type is 2
        d2=d.copy();          //copy d
        d=add(mul(b2,c),mul(a,d)).div(b.mul(2)); //set d = derivative of b
        c=add(c,d2).mul(0.5f); //set c = derivative of a
      }
      a=add(a,b2).mul(0.5f);   //set a = arithmeic mean
    }
    
    if(absq(a.sub(b))>=1E-10f)            { println("AGM Error: " +str(a)+"!="+str(b)); } //if a!=b,
    if(type==2 && absq(c.sub(d))>=1E-10f) { println("AGM' Error: "+str(c)+"!="+str(d)); } //or c!=d, it's an error as the series didn't converge fast enough
    
    return new Complex[] {a,c.mul(k)}; //return an array containing the AGM and its derivative (times k)
  }
  
  public static Complex completeF(Complex k) { //returns the complete elliptic integral of the first kind for complex k
    if(k.equals(0)) { return complex(HALFPI); } //special case: if k==0, return π/2
    if(k.equals(1)) { return complex(INF);    } //special case: if k==1, return ∞
    
    return div(HALFPI,AGM_method(sqrt(sub(1,k)),1)[0]); //return π/(2*AGM)
  }
  
  public static Complex completeE(Complex k) { //returns the complete elliptic integral of the second kind for complex k
    if(k.equals(0)) { return complex(HALFPI); } //special case: k==0, return π/2
    if(k.equals(1)) { return one();           } //special case: k==1, return 1
    
    Complex[] AGM=AGM_method(sqrt(sub(1,k)),2); //find the AGM & AGM'
    
    return k.mul(AGM[1]).div(AGM[0]).add(sub(1,k)).div(AGM[0]).mul(HALFPI); //return π/(2*AGM) * (k√(1-k)*(AGM'/AGM)+1-k)
  }
  
  public static Complex completePI(Complex n, Complex k) { //returns the complete elliptic integral of the third kind for complex k and n
    if(k.equals(0)) { return div(HALFPI,sqrt(sub(1,n)));      } //special case: k==0, return π/(2√(1-n))
    if(n.equals(0)) { return completeF(k);                    } //special case: n==0, return F(k)
    if(k.equals(1) || n.equals(1)) { return new Complex(INF); } //special case: k==1 or n==1, return ∞
    
    Complex[] storage=carlson(zero(),sub(1,k),one(),sub(1,n),3); //compute the carlson symmetric R_F and R_J
    
    Complex ans=storage[0].add(mul(storage[1],n.div(3))); //compute R_F+n/3*R_J
    
    return ans; //return the result
  }
  
  private static Complex[] carlson(Complex x, Complex y, Complex z, Complex p, int type) { //this returns the carlson symmetric R_F of x,y,z (and possibly RJ of x,y,z,p if type is 2 or 3)
    Complex mu=add(x,y.add(z)).div(3); //this is the mean between the x, y, and z
    
    double delta=10000*Math.max(Math.max(absq(x.sub(mu)), absq(y.sub(mu))), absq(z.sub(mu))); //this is how far the inputs are from the mean
    
    if(type==3) { delta=Math.max(delta, 10000*absq(p.sub(mu))); }                            //if the type is 3, we need to include p in our results
    
    Complex part=zero(); //this is the sum of all the stuff we add on to the R_D function (even if it's only for type 2 or 3, it still must be declared in this scope)
    double pow4=1.0D;    //this will divide by 4 each iteration, and will be multiplied by a sum we'll perform at the end to find R_D
    
    while(delta > absq(mu)) { //while all terms are far apart, use the following duplication formula,
      Complex s1=sqrt(x), s2=sqrt(y), s3=sqrt(z);        //compute the √ of x, y, and z
      Complex lambda=s1.mul(add(s2,s3)).add(mul(s2,s3)); //compute lambda in our duplication formula
      
      delta*=0.0625D; //divide our square difference by 16
      
      if(type==2||type==3) { //if the type is either 2 or 3, there's an extra step to this
        if(type==2) {
          part.addeq(div(3*pow4, mul(s3,add(s1,s3),add(s2,s3)) )); //type 2: add on a special case of type 3 where p==z
        }
        else        {         //type 3: unlike type 2, this isn't a special case, and we have to give p some special treatment since it isn't z
          Complex s4=sqrt(p); //find the square root of p
          Complex sto=sqrt(mul(sub(p,x),sub(p,y),sub(p,z))); //store this thing to save on multiplications
          part.addeq(atan( sto.div(mul(add(s1,s4),add(s2,s4),add(s3,s4))) ).mul(6*pow4).div(sto)); //add this big ass equation
          p=add(p,lambda).div(4); //perform the "duplication" on p as well
        }
        pow4*=0.25D; //pow4 must divide by 4
      }
      
      x =add(x ,lambda).muleq(0.25f);  //set x, y, z, and mu to themselves plus lambda all over 4
      y =add(y ,lambda).muleq(0.25f);  //for some reason, this is called a "duplication formula"
      z =add(z ,lambda).muleq(0.25f);
      mu=add(mu,lambda).muleq(0.25f);
    }
    
    //now we compute the R_F function
    
    Complex z1=x.div(mu).sub(1), z2=y.div(mu).sub(1), z3=z.div(mu).sub(1); //these are the ratio between how far x y & z are from mu and mu itself
    Complex E2=z1.mul(add(z2,z3)).add(mul(z2,z3)), E3=mul(z1,z2,z3);       //E2 & E3 are the sum of all 2nd & 3rd degree products with x,y,z
    
    Complex sum=sub(1,E2.div(10)).sub(E3.div(14)).add(sq(E2).div(24)).add(mul(E2,E3,3.0D/44)).add(sq(E3).mul(3.0D/104)).sub(cub(E2).mul(5.0D/208)).sub(mul(sq(E2),E3,0.0625D)); //approximation
    //1-E2/10+E3/14+E2^2/24+3E2E3/44+3E3^2/104-5E2^3/208-E2^2E3/16
    
    sum.diveq(sqrt(mu)); //divide the sum by the square root of mu, and we now have R_F
    
    if(type==1) { return new Complex[] {sum}; } //if the type is 1, return only the R_F function
    if(type==2) { p=z.copy();                 } //if the type is 2, set p equal to z
    
    //note now the type can only be 2 or 3
    
    //now we compute the R_J function
    
    mu=add(add(x,y),add(z,p.mul(2))).div(5); //change the mu value
    
    z1=x.div(mu).sub(1); z2=y.div(mu).sub(1); z3=z.div(mu).sub(1); //change the z values
    Complex z4=p.div(mu).sub(1);                                   //create a new z value
    
    E2=z1.mul(add(z2,z3)).add(mul(z2,z3)).sub(sq(z4).mul(3));
    E3=z4.mul(z1.mul(add(z2,z3)).add(mul(z2,z3)).sub(sq(z4))).mul(2).add(z1.mul(mul(z2,z3)));
    Complex E4=z4.mul(z1.mul(add(z2,z3)).add(mul(z2,z3))).add(mul(mul(z1,z2),mul(z3,2))).mul(z4);
    Complex E5=mul(mul(z1,z2),mul(z3,sq(z4)));
    
    Complex sum2=sub(1,E2.mul(3.0D/14)).sub(E3.div(6)).sub(E4.mul(3.0D/22)).sub(E5.mul(3.0D/26)).add(sq(E3).mul(9.0D/88)).add(mul(E2,E3,9.0D/52)).add(mul(E2,E4,0.15D)).add(mul(E2,E5,9.0D/68)).add(sq(E3).mul(0.075D)).add(mul(E3,E4,9.0D/68)).sub(cub(E2).div(16)).sub(mul(sq(E2),E3,45.0D/272));
    //1-3E2/14-E3/6-3E4/22-3E5/26+9E3^2/88+9E2E3/52+3E2E4/20+9E2E5/68-E2^3/16-45E2^2E3/272
    
    sum2.muleq(pow4);             //divide the sum by 4^(whatever)
    sum2.diveq(mul(mu,sqrt(mu))); //divide by mu^(3/2)
    sum2.addeq(part);             //add the additional part
    
    return new Complex[] {sum,sum2}; //return the result
  }
  
  public static Complex incompleteF(Complex theta, Complex k) {   //returns the incomplete elliptic F function of complex numbers theta and k
    
    if(k.equals(0)) { return theta.copy(); } //k==0: the integral evaluates to theta
    if(k.equals(1)) {                        //k==1: the integral simplifies, but isn't always defined
      if(theta.re>= HALFPI) { return complex( INF); } //theta>=π/2: return ∞
      if(theta.re<=-HALFPI) { return complex(-INF); } //theta<=-π/2: return -∞
      return ln(add(tan(theta),sec(theta)));          //otherwise, return ln(sec(theta)+tan(theta))
    }
    if(Math.abs(theta.im)>100) {                               //theta has large imaginary part: approximate the integral with two complete elliptic integrals
      double adjust=Math.round((theta.re-0.5f*arg(k))/Math.PI); //find how many times π goes into theta
      Complex ans=(theta.im>0) ? completeF(sub(1,k)).mulI() : completeF(sub(1,k)).divI(); //set our answer to ±K(1-k)i
      if(adjust!=0) { ans.addeq(completeF(k).mul(2*adjust)); } //if π goes into theta, add on K(k) times 2*adjust
      return ans;                                              //return the result
    }
    
    double adjust=Math.round(theta.re/Math.PI); //find how many times π goes into theta
    Complex inp=theta.sub(Math.PI*adjust);      //our input is theta minus π times our adjustment
    
    if(inp.equals(0))       { return completeF(k).mul(2*adjust);   } //if the modulo is 0 or -π/2, we can finish the calculation with completeF
    if(inp.equals(-HALFPI)) { return completeF(k).mul(2*adjust-1); }
    
    Complex sum=carlson(sq(cos(inp)),sub(1,sq(sin(inp)).mul(k)),one(),zero(),1)[0]; //compute the RF of cos²,1-ksin²,1
    
    sum.muleq(sin(inp)); //multiply by the sine
    
    if(adjust!=0) { sum.addeq(completeF(k).mul(2*adjust)); } //add F(k) times how many times π goes into theta
    
    return sum; //return the result
  }
  
  public static Complex incompleteE(Complex theta, Complex k) { //returns the incomplete elliptic E function of complex theta and k
    
    if(k.equals(0)) { return theta.copy(); } //k==0: just return theta
    if(k.equals(1)) {                        //k==1: return the integral of |cos(x)|dx
      return sin(theta).mul(Math.IEEEremainder(theta.re/Math.PI+0.5f,2)>0 ? 1 : -1).sub(2*Math.round(-theta.re/Math.PI));
    }
    if(Math.abs(theta.im)>100) {                               //theta has large imaginary part: approximate with exponents
      Complex ans=mul(exp(theta.im>0 ? theta.divI() : theta.mulI()),sqrt(k),0.5f); //take √(k)e^(theta/±i)/2
      ans=(theta.im>0 == ans.isRoot()) ? ans.mulI() : ans.divI();                 //mult/div by i, depending on csgn, and on sgn of imag part
      //Most of the equation is solved. This always evaluates to something huge, thus the rest of the approximation is insignificant...
      
      if(ans.re==0 || ans.im==0) { //...unless either the re or im is 0
        Complex term=sub(completeF(sub(1,k)),completeE(sub(1,k))); //compute F(1-k)-E(1-k)
        term=theta.im>0 ? term.mulI() : term.divI();               //multiply by ±i
        
        double adjust=Math.round((theta.re-0.5f*arg(k))/Math.PI);  //find how many E(k)'s to tack on
        if(adjust!=0) { term.addeq(completeE(k).mul(2*adjust)); } //if it goes in at all, tack on those E(k)'s
        
        ans.addeq(term); //add this term to our integral
      }
      
      return ans; //return the result
    }
    
    double adjust=Math.round(theta.re/Math.PI); //find how many times π goes into theta
    Complex inp=theta.sub(Math.PI*adjust);      //our input is theta minus π times our adjustment
    
    if(inp.equals(0))       { return completeE(k).mul(2*adjust);   } //if the modulo is 0 or -π/2, we can finish the calculation with completeE
    if(inp.equals(-HALFPI)) { return completeE(k).mul(2*adjust-1); }
    
    Complex sins=sin(inp); //compute the sine
    
    Complex[] storage=carlson(sq(cos(inp)),sub(1,mul(sq(sins),k)),one(),zero(),2); //find R_F and R_J
    
    Complex sum=storage[0], sum2=storage[1]; //store these forms as two variables
    
    sum2.muleq(sq(sins).mul(k.div(3)));
    
    sum.subeq(sum2);                       //subtract the other sum
    sum.muleq(sins);                       //multiply entire sum by sin(theta)
    if(adjust!=0) {
      sum.addeq(completeE(k).mul(2*adjust)); //add the complete elliptic E times how many times π goes into theta
    }
    
    return sum; //return the result
  }
  
  //////////////////////////// OTHER //////////////////////////////
  
  
}
//Since on Android, you can have multiple touch events, but on PC, there's only one, we need a class to store cursors.
//On PC, there's always 1, on Android, it varies. We can customize the code for both, but we'll use cursors to keep things reusable.

public static class Cursor {
  
  ////////////////// ATTRIBUTES ///////////////////
  
  int id = 0;           //The ID of this cursor. Used primarily for compatibility with touch events on Android. Always 0 on PCs w/out multitouch
  
  float x, y;           //x and y position
  float dx, dy, ex, ey; //x and y in the previous draw cycle, and in the previous event. e is ignored on Android due to issues
  
  byte press=0;         //whether each mouse button is pressed. On Android, right & center are ignored
  //as an optimization, the 3 bools were combined into 1 byte, which both optimizes storage & allows us to quickly check if it's in a particular state (i.e. ==0, !=0)
  
  boolean active = true; //when false, this cursor is considered deactivated. The alternative to this would be to simply finalize this object and have it be null, but that might be unsafe
  //TODO figure out if the active boolean ever gets used in practice
  Box select = null;     //the behavior of this cursor and how it interacts with UI elements, characterized by the object it touched when it was most recently pressed. More specifically, that object's class
  //NOTE Maybe I shouldn't have the select thing here? I mean, it makes perfect sense, but also it conflicts with a general philosophy that the Cursor should act all on its own, regardless of the inclusion of a UI library
  float xi, yi; //initial x and y, the position it was on the last time it was pressed down
  
  ///////////////////// CONSTRUCTORS ////////////////////
  
  Cursor() { }
  
  Cursor(float x_, float y_) { x=dx=ex=x_; y=dy=ey=y_; }
  
  Cursor(int id_, float x_, float y_) { this(x_,y_); id=id_; }
  
  /////////////////// GETTERS ///////////////////////
  
  public int getId() { return id; }
  
  public boolean left  () { return (press&4)==4; }
  public boolean center() { return (press&2)==2; }
  public boolean right () { return (press&1)==1; }
  public boolean allPressed() { return press==7; }
  public boolean anyPressed() { return press!=0; }
  
  public Box getSelect() { return select; }
  
  //////////////// MUTATORS ///////////////////////
  
  public Cursor setId(final int i) { id=i; return this; }
  
  public void updatePos(float mouseX, float mouseY) { ex=x; ey=y; x=mouseX; y=mouseY; } //updates position
  
  public void press(int mouseButton) { switch(mouseButton) {
    case LEFT: press|=4; break; case CENTER: press|=2; break; case RIGHT: press|=1;
  } xi=x; yi=y; }
  
  public void release(int mouseButton) { switch(mouseButton) {
    case LEFT: press&=~4; break; case CENTER: press&=~2; break; case RIGHT: press&=~1;
  } }
  
  public void press  () { press  (LEFT); } //Press/release w/out specifying button.
  public void release() { release(LEFT); } //LEFT is default button
  
  public void setSelect(final Box box) { //sets which box this cursor is selecting
    if(select instanceof Panel) { ((Panel)select).release(this); } //if it was a panel, start a release event
    if(   box instanceof Panel) { ((Panel)   box).press  (this); } //if it is a panel, start a press event
    if(box==null && select instanceof Textbox.CursorMover) { //if it was a cursor mover, AND we're swapping to null:
      ((Textbox.CursorMover)select).release(this);           //perform the release event on it, allowing us to move the text cursor wherever we want
    }
    select = box; //finally, set select
  }
  
  ////////////// DEFAULT FUNCTIONS //////////////////
  
  @Override
  public Cursor clone() {
    Cursor result = new Cursor(id,x,y); result.dx=dx; result.dy=dy; result.ex=ex; result.ey=ey; result.press=press;
    result.active=active; result.select=select; result.xi=xi; result.yi=yi;
    return result;
  }
}
public static enum EntryType { //it's useful to classify entries in an equation into types. Namely, literals, constants, left-associative operators, right-associative operators, left parentheses, right parentheses, left-hand functions, right-hand functions, ???, commas, and unclassified
  NUM, CONST, LASSOP, RASSOP, LPAR, RPAR, LFUNC, RFUNC, LFUNC2, COMMA, NONE;
  
  public boolean leftNum () { return this==NUM || this==CONST || this==LPAR || this==LFUNC || this==LFUNC2; } //acts like a number on the left: numeral, constant, (, left function
  public boolean rightNum() { return this==NUM || this==CONST || this==RPAR || this==RFUNC;                 } //acts like a number on the right: numeral, constant, ), right function
  
  public boolean isOperator() { return this==LASSOP || this==RASSOP; } //is an operator (regardless of associativity)
  public boolean hasLeftPar() { return this==LPAR   || this==LFUNC;  } //has left parenthesis (thus needs to be closed)
}

public static class Entry {
  String id;      //string identifier
  EntryType type; //entry type
  byte prec;      //operator precedence
  short inps=0;   //how many inputs it has
  MathObj asNum=null; //record the math object as a number (speeds up graphing)
  
  Equation[] links = new Equation[0]; //the equation(s) this links to (usually empty, but sometimes not in the case of functions that recursively call other equations)
  
  //the variable this represents
  //the equation this links to
  
  public Entry(String i) {
    id = i;                  //set ID
    type = getType(i);       //get entry type
    prec = getPrecedence(i); //get precedence
  }
  
  private Entry(String i, EntryType ty, byte pr) {
    id=i; type = ty; prec = pr; //set the id, type, & precision
  }
  
  @Override
  public Entry clone() {
    return new Entry(id, type, prec);
  }
  
  //@Override
  public boolean equals(Entry e) {
    return id.equals(e.id);
  }
  
  public static EntryType getType(String i) { //gets the entry type
    
    boolean isDouble = true; //try to cast to double
    try { Double.parseDouble(i); }
    catch(NumberFormatException e) { isDouble = false; }
    
    if(isDouble) { return EntryType.NUM; } //can be cast to double: numeral type
    if(i.length()==1 && Character.isLetter(i.charAt(0))) { return EntryType.CONST; } //is a letter: constant type
    for(String s : Equation.varList) { if(s.equals(i)) { return EntryType.CONST; } } //is part of the variable list: constant type
    if(!i.equals("(") && i.charAt(i.length()-1)=='(') { return EntryType.LFUNC; }    //ends in left parenthesis: left function type
    
    switch(i) {
      case "+": case "-": case "*": case "/": case "//": case "%":
      case "&": case "|": case "&&": case "||": case "==": case "!=":
      case "=": case "<": case ">": case "<=": case ">=":            return EntryType.LASSOP; //these are all left associative operators
      case "^":                                                      return EntryType.RASSOP; //^: right associative operator
      case "(":                                                      return EntryType.LPAR;   //(: left parenthesis
      case ")":                                                      return EntryType.RPAR;   //): right parenthesis
      case "²": case "³": case "!":                                  return EntryType.RFUNC;  //right function type
      case "(-)":                                                    return EntryType.LFUNC2; //left function w/out parenthesis
      case ",":                                                      return EntryType.COMMA; //comma
    }
    return EntryType.NONE; //otherwise, you done fucked up
  }
  
  public static byte getPrecedence(String i) { //gets the operator precedence
    if(i==null) { return 0; } //special case: return 0
    
    switch(i) {
      //boolean
      case "||": return 1; //OR: lowest precedence
      case "&&": return 2; //AND: next precedence
      
      case "|": return 3; //bitwise OR
      case "&": return 4; //bitwise AND
      
      //comparisons
      case "=": case "==": case "!=":           return 5; //tests for equality
      case "<": case ">": case "<=": case ">=": return 6; //inequalities
      
      //arithmetic
      case "+": case "-":                      return 7; //lowest precedence: +/-
      case "*": case "/": case "%": case "//": return 8; //next precedence: times, divide, modulo, truncated divide
      case "^":                                return 9; //highest precedence: exponent
    }
    
    return 0; //for pretty much anything else, precedence doesn't even apply
  }
  
  public String      getId() { return   id; }
  public EntryType getType() { return type; }
  public int getPrecedence() { return prec; }
  
  public boolean leftNum() { return type.leftNum(); } //true if it can be treated like a number on the left
  public boolean rightNum() { return type.rightNum(); } //true if it can be treated like a number on the right
  public boolean isOperator() { return type.isOperator(); } //true if it's an operator (regardless of associativity)
  public boolean hasLeftPar() { return type.hasLeftPar(); } //true if it has a left parenthesis (needs closing)
  
  //public static boolean isLetter(char c) { return c>='A' && c<='Z' || c>='a' && c<='z'; }
}
public static class Equation implements Iterable<Entry> {
  
  ArrayList<Entry> tokens = new ArrayList<Entry>(); //all the entries in the equation
  
  public Equation() { }
  
  public Equation(ParseList p) {
    for(String s : p) {
      tokens.add(new Entry(s)); //add each token
    }
  }
  
  private Equation(ArrayList<Entry> toks) { tokens = toks; } //set each token individually
  
  @Override
  public String toString() {
    String res = "";
    for(Entry s : tokens) { res+=s.getId()+", "; }
    return res;
  }
  
  public int size() { return tokens.size(); }
  public Entry get(int i) { return tokens.get(i); }
  public void add(Entry e) { tokens.add(e); }
  public void add(int i, Entry e) { tokens.add(i,e); }
  public void remove(int i) { tokens.remove(i); }
  
  public boolean isEmpty() { return size()==0 || size()==2 && tokens.get(0).id.equals("(") && tokens.get(1).id.equals(")"); }
  
  @Override
  public Iterator<Entry> iterator() {
    return tokens.iterator();
  }
  
  public void squeezeInTimesSigns() { //squeezes * signs between adjacent numbers
    for(int n=1;n<size();n++) { //loop through every token (except the initial ( at the beginning)
      Entry curr = get(n), trail = get(n-1); //get the current & previous entries
      
      if(curr.leftNum() && trail.rightNum()) { //2 adjacent numbers:
        tokens.add(n,new Entry("*"));        //squeeze a * sign between them
        ++n;                                 //move 1 right
      }
    }
  }
  
  public void setUnaryOperators() { //changes lone + and - signs to unary operators
    for(int n=1;n<size();n++) { //loop through every token (except the initial ( at the beginning)
      Entry curr = get(n), trail = get(n-1); //record current & previous entries
      if((curr.getId().equals("+") || curr.getId().equals("-")) && !trail.rightNum()) { //if this is a + or -, and the previous token isn't a number:
        if(curr.getId().equals("+")) { tokens.remove(n); --n;          } //+: remove token & go back 1 step
        else                         { tokens.set(n,new Entry("(-)")); } //-: swap minus sign with negation
      }
    }
  }
  
  public String validStrings() {
    for(Entry e : this) {
      if(e.getType()==EntryType.NONE) { return "Error: \""+e.getId()+"\" is not a valid token"; }
    }
    return "valid";
  }
  
  public String validPars() { //checks that all parentheses are closed (returns a message about its validity)
    int parVar = 0; //# of ( minus # of ) (if ever negative, config is invalid)
    for(int n=1;n<size()-1;n++) { //loop through all entries (except the 1st & last)
      Entry e = get(n);
      switch(e.getType()) {
        case LPAR: case LFUNC: ++parVar; break; //left ( or left func: increment
        case RPAR:             --parVar; break; //right ): decrement
      }
      if(parVar<0) { return "Error: unclosed right parentheses"; } //if parvar is ever negative, configuration is invalid
    }
    return (parVar==0) ? "valid" : "Error: unclosed left parentheses"; //return valid iff # of ( == # of )
  }
  
  public String leftHanging() { //tests for an error I call "left me hanging"
    for(int n=1;n<size();n++) { //loop through all entries (except the first)
      Entry curr = get(n), trail = get(n-1); //record current & previous entries
      
      EntryType type = trail.getType();
      if((type.isOperator()||type.hasLeftPar()||type==EntryType.LFUNC2||type==EntryType.COMMA) && !curr.leftNum()) { return "Error: "+trail.getId()+" followed by "+curr.getId(); }
      //left version: operator, left func, (, or comma is followed by non-number
      
      type = curr.getType();
      if((type.isOperator()||type==EntryType.RFUNC||type==EntryType.RPAR||type==EntryType.COMMA) && !trail.rightNum()) { return "Error: "+trail.getId()+" followed by "+curr.getId(); }
      //right version: operator, right func, ), or comma is preceded by non-number
    }
    return "valid"; //no error encountered: return valid
  }
  
  public String countCommas() { //tests for functions with the wrong number of commas
    class Fusion { Entry entry; int commas; Fusion(Entry e, int c) { entry=e; commas=c; } public void increment() { commas++; } }
    
    Stack<Fusion> records = new Stack<Fusion>(); //a stack of functions, as well as integers to count how many commas they have
    for(Entry curr : this) { //loop through all the entries
      if(curr.getType().hasLeftPar()) {   //if this has a left parenthesis,
        records.push(new Fusion(curr,0)); //push it onto the stack
      }
      else if(curr.getType()==EntryType.COMMA) { //otherwise, if it's a comma:
        Fusion fuse = records.peek(); //record the current top of the stack
        fuse.increment();             //increment the number of commas
        if(fuse.commas+1 > maxInps(fuse.entry.id)) { return "Error: too many inputs for function "+fuse.entry.id; } //if too many, return message saying there are too many
      }
      else if(curr.getType()==EntryType.RPAR) {
        Fusion fuse = records.peek(); //record the current top of the stack
        if(fuse.commas+1 < minInps(fuse.entry.id)) { return "Error: too few inputs for function "+fuse.entry.id; } //if too few, return message saying there are too few
        records.pop(); //pop this off the stack
      }
    }
    return "valid"; //no error encountered: return valid
  }
  
  
  
  public Equation shuntingYard() { //performs the shunting yard algorithm on it (damages input)
    Stack<Entry> opStack = new Stack<Entry>(); //operator stack
    Equation output = new Equation();          //output
    
    while(size()!=0) { //perform the following loop until size is 0
      Entry curr = get(0); //grab first token
      Entry topOp;         //operator on top of stack
      
      switch(curr.getType()) { //each step is determined by the current token type
        case  NUM: case CONST: case  RFUNC:  output.add(curr); break; //number or right function: move to end of output stack
        case LPAR: case LFUNC: case LFUNC2: opStack.add(curr); break; //( or left function: push to top of operator stack
        case LASSOP: case RASSOP: case COMMA: {                       //operator or comma:
          
          /*   SHUNTING YARD RULE FOR OPERATORS:
          push the top operator to the output stack as long as it's not a ( or left function and also either
          ∙ has greater precedence than the token (from the input stack)
          ∙ has equal precedence to the token and is left associative, or
          ∙ is a function without a ( and the token is left associative or a comma
          after that, you can push the current token to the operator stack */
          
          topOp = opStack.peek(); //get operator at top of stack
          while(!topOp.hasLeftPar() && (topOp.getPrecedence() > curr.getPrecedence() ||
                topOp.getPrecedence()==curr.getPrecedence() && curr.getType()==EntryType.LASSOP ||
                topOp.getType()==EntryType.LFUNC2 && (curr.getType()==EntryType.LASSOP || curr.getType()==EntryType.COMMA))) { //loop through op stack based on above rules
            output.add(topOp);      //push the top operator to the operator stack
            opStack.pop();          //pop top operator
            topOp = opStack.peek(); //replace top op
          }
          opStack.push(curr); //finally, push the current operator onto the operator stack
        } break;
        case RPAR: //right parenthesis
          topOp = opStack.peek();      //get operator at top of stack
          while(!topOp.hasLeftPar()) { //loop until top op can close the )
            output.add(topOp);       //push to output stack
            opStack.pop();           //pop from operator stack
            topOp = opStack.peek();  //replace top operator
          }
          if(topOp.getType()==EntryType.LFUNC) { //after exiting the loop, if the operator is a function:
            output.add(topOp);
          }
          opStack.pop(); //pop top of operator stack
        break;
      }
      remove(0); //pop first token
    }
    return output; //return output
  }
  
  public Equation killCommas() { //removes the commas, then tells us how many inputs each function has
    int commaCount=0; //keep track of how many commas there are
    for(int n=0;n<size();n++) { //loop through all entries
      Entry token = tokens.get(n);      //load this token
      EntryType type = token.getType(); //load the entry type
      
      if(type==EntryType.COMMA) { commaCount++; tokens.remove(n); n--; } //commas: increment the comma count, remove the comma, move back 1
      else if(type.isOperator()) { token.inps = 2; } //operators take 2 inputs
      else if(type.hasLeftPar()) { token.inps = (short)(commaCount+1); commaCount=0; } //functions w/ parentheses take however many inputs there are commas (plus 1)
      else if(type==EntryType.LFUNC2 || type==EntryType.RFUNC) { token.inps = 1; } //functions w/out parentheses can only take 1 input
      
      if(type!=EntryType.COMMA && commaCount!=0) { println("How did this happen? How are there "+commaCount+" commas, but this isn't a comma?"); }
    }
    return this; //return result
  }
  
  public void parseNumbers() { //parses all the numbers before solving (makes graphing and recursion easier)
    for(Entry entry : this) if(entry.getType()==EntryType.NUM) {
      entry.asNum = new MathObj(entry);
    }
  }
  
  //@return: in the end, we will find that our solve function separates this into n distinct equations. This returns what n is (n is supposed to be 1. If it's not, it's an error)
  public int arrangeRecursiveFunctions() { //this looks at all functions which recursively call other functions, then puts the latter functions into the former function's link
    
    ArrayList<ArrayList<Entry>> groups = new ArrayList<ArrayList<Entry>>(); //arraylist of grouped together entries. Each time we reach a function, we group together that function w/ its inputs
    
    for(int n=0;n<size();n++) { //loop through all entries
      Entry token = tokens.get(n); //grab the current entry
      switch(token.getType()) {
        case NUM: case CONST: { //number or constant:
          ArrayList<Entry> adder = new ArrayList<Entry>(1); adder.add(token); //create new group to add to the list
          groups.add(adder);                                                  //add group to the list
        } break;
        default: { //otherwise:
          
          if(token.getId().equals(":")) { //special case: the ternary operators:
            token.id="?:"; token.type = EntryType.LFUNC2; //change this : operator into a single fused ternary operator
            //TODO the rest of this
          }
          
          int[] linkGuide = recursiveCheck(token.getId()); //get which link needs to go where
          token.links = new Equation[linkGuide.length];    //resize list of links
          
          int zInd = groups.size()-token.inps; //locate the index of the zeroth input
          
          for(int k=0;k<linkGuide.length;k++) { //loop through all things we have to link to
            ArrayList<Entry> link = groups.get(zInd+linkGuide[k]); //easy part: load the entry list at each index,
            token.links[k] = new Equation(link); //convert to an equation, then make that the link
            
            //hard part: remove that linked equation from the token list
            int ind = tokens.indexOf(link.get(0)); //find where in the tokens list is the first entry of the link
            for(int i=0;i<link.size();i++) { //loop through all entries in the link
              tokens.remove(ind); n--;       //remove each element, backtrack in the list
            }
            groups.remove(zInd+linkGuide[k]); //remove this group
            
            token.inps--; zInd--; //decrement the number of inputs, decrement the zeroth index
          }
          //TODO check and see that this still works even if there are multiple links
          
          zInd = groups.size()-token.inps; //reset the zeroth index
          for(int k=1;k<token.inps;k++) { //loop through all inputs after the 0th
            groups.get(zInd).addAll(groups.get(zInd+1)); //concatenate the next group onto the 0th group
            groups.remove(zInd+1);                       //remove that next group
          }
          groups.get(zInd).add(token); //concatenate this token onto the 0th group
        }
      }
      /*println();
      for(int k=0;k<groups.size();k++) {
        for(int i=0;i<groups.get(k).size();i++) { print(groups.get(k).get(i).getId()+", "); }
        println();
      }
      println();*/
    }
    //println(this); //DEBUG
    return groups.size(); //return how long this list is in the end
  }
  
  /*String detectVariableScope() { //returns whether or not each variable was declared in this scope
    //TODO this
  }*/

  public MathObj solve(HashMap<String, MathObj> mapper) {
    ArrayList<MathObj> out = new ArrayList<MathObj>(); //array of all the mathematical objects we analyze to read this
    //int commaCount = 0;
    
    for(Entry e : this) {
      
      switch(e.getType()) {
        case NUM: out.add(e.asNum.clone()); break;
        case CONST: {
          MathObj vari = mapper.get(e.getId());
          if(vari==null) { out.add(new MathObj(e)); }
          else { out.add(vari.clone()); }
        } break;
        case COMMA:
          println("HOW ARE THERE STILL COMMAS? I THOUGHT I KILLED YOU!!!"); //DEBUG
        break;
        case LASSOP: case RASSOP: case LFUNC: case RFUNC: case LFUNC2: {
          if(out.size()<1) { return new MathObj("FATAL ERROR: postfix function without any tokens preceding it"); }
          if(out.size()<e.inps) { return new MathObj("BIG ERROR: too many commas / not enough inputs in function "+e.getId()+" ("+out.size()+", "+e.inps+")"); }
          //if(e.inps < minInps(e.getId()) || e.inps > maxInps(e.getId())) { return new MathObj("Error: "+e.inps+" input"+(e.inps==1?"":"s")+" for function "+e.getId()); }
          
          MathObj inp[] = new MathObj[e.inps];   //now, we have to group together all the inputs
          boolean allNums = true, allBools=true; //this records whether all inputs are numbers, the other records whether they're all bools
          for(int n=0;n<e.inps;n++) {
            inp[n] = out.get(n+out.size()-e.inps); //load each input
            allNums &= inp[n].isNum();             //only true if all of them are numbers
            allBools &= inp[n].isBool();           //only true if all of them are bools
          }
          
          String id = e.getId(); //grab the function name
          
          if(allNums) { //if they're all numbers
            Complex num = inp[0].number; //grab the first input
            
            switch(id) {
              case "+": inp[0].number.addeq(inp[1].number); break;
              case "-": inp[0].number.subeq(inp[1].number); break;
              case "*": inp[0].number.muleq(inp[1].number); break;
              case "/": inp[0].number.diveq(inp[1].number); break;
              case "%": inp[0].number = inp[0].number.mod(inp[1].number); break;
              case "^": {
                if(inp[0].number.equals(Math.E)) { inp[0].number = inp[1].number.exp(); }
                else { inp[0].number = inp[0].number.pow(inp[1].number); }
              } break;
              case "//": inp[0].number.set(inp[0].number.div(inp[1].number).floor(),0); break;
              
              case "=": case "==": { inp[0].bool=inp[0].number.equals(inp[1].number); inp[0].number=null; inp[0].type = MathObj.VarType.BOOLEAN; } break;
              case "!=":           { inp[0].bool=!inp[0].number.equals(inp[1].number); inp[0].number=null; inp[0].type = MathObj.VarType.BOOLEAN; } break;
              case "<":            { inp[0].bool=inp[0].number.re<inp[1].number.re || inp[0].number.re==inp[1].number.re && inp[0].number.im<inp[1].number.im; inp[0].number=null; inp[0].type = MathObj.VarType.BOOLEAN; } break;
              case ">":            { inp[0].bool=inp[0].number.re>inp[1].number.re || inp[0].number.re==inp[1].number.re && inp[0].number.im>inp[1].number.im; inp[0].number=null; inp[0].type = MathObj.VarType.BOOLEAN; } break;
              case "<=":           { inp[0].bool=inp[0].number.re<inp[1].number.re || inp[0].number.re==inp[1].number.re && inp[0].number.im<=inp[1].number.im; inp[0].number=null; inp[0].type = MathObj.VarType.BOOLEAN; } break;
              case ">=":           { inp[0].bool=inp[0].number.re>inp[1].number.re || inp[0].number.re==inp[1].number.re && inp[0].number.im>=inp[1].number.im; inp[0].number=null; inp[0].type = MathObj.VarType.BOOLEAN; } break;
              
              case "(-)": { inp[0].number.negeq();    } break;
              case "√(" : { inp[0].number=num.sqrt(); } break;      case "∛("  : { inp[0].number=num.cbrt();     } break;
              case "ln(": { inp[0].number=num.  ln(); } break;      case "log(": { inp[0].number=Cpx.log10(num); } break;
              case "²"  : { inp[0].number=num.  sq(); } break;      case  "³"  : { inp[0].number=num.cub();      } break;
              
              
              case "sin(": { inp[0].number=num.sin(); } break;     case "cos(": { inp[0].number=num.cos(); } break;     case "tan(": { inp[0].number=num.tan(); } break;
              case "sec(": { inp[0].number=num.sec(); } break;     case "csc(": { inp[0].number=num.csc(); } break;     case "cot(": { inp[0].number=num.cot(); } break;
              case "sinh(": { inp[0].number=num.sinh(); } break;   case "cosh(": { inp[0].number=num.cosh(); } break;     case "tanh(": { inp[0].number=num.tanh(); } break;
              case "sech(": { inp[0].number=num.sech(); } break;   case "csch(": { inp[0].number=num.csch(); } break;     case "coth(": { inp[0].number=num.coth(); } break;
              
              case "asin(": case "sin⁻¹(": { inp[0].number=num.asin(); } break;     case "acos(": case "cos⁻¹(": { inp[0].number=num.acos(); } break;
              case "atan(": case "tan⁻¹(": { inp[0].number=num.atan(); } break;     case "acot(": case "cot⁻¹(": { inp[0].number=num.acot(); } break;
              case "asec(": case "sec⁻¹(": { inp[0].number=num.asec(); } break;     case "acsc(": case "csc⁻¹(": { inp[0].number=num.acsc(); } break;
              case "asinh(": case "sinh⁻¹(": { inp[0].number=num.asinh(); } break;     case "acosh(": case "cosh⁻¹(": { inp[0].number=num.acosh(); } break;
              case "atanh(": case "tanh⁻¹(": { inp[0].number=num.atanh(); } break;     case "acoth(": case "coth⁻¹(": { inp[0].number=num.acoth(); } break;
              case "asech(": case "sech⁻¹(": { inp[0].number=num.asech(); } break;     case "acsch(": case "csch⁻¹(": { inp[0].number=num.acsch(); } break;
              
              
              case  "Re(": { inp[0].number=new Complex(   num.re); } break;    case  "Im(": { inp[0].number=new Complex(   num.im); } break;
              case "abs(": { inp[0].number=new Complex(num.abs()); } break;    case "arg(": { inp[0].number=new Complex(num.arg()); } break;
              case "abs²(": { inp[0].number=new Complex(num.absq()); } break;  case "conj(": { inp[0].number.conjeq(); } break;
              case "abs2(": { inp[0].number=num.abs2();            } break;    case "sgn(": { inp[0].number=num.sgn(); } break;
              case "csgn(": { inp[0].number=new Complex(num.csgn()); } break;
              
              case "floor(": { inp[0].number=new Complex(num.floor()); } break;
              case "ceil(": { inp[0].number=new Complex(num.ceil()); } break;
              case "round(": { inp[0].number=new Complex(num.round()); } break;
              case "frac(": { inp[0].number.subeq(num.floor()); } break;
              
              case "θ(": { inp[0].number=num.re<=0?Cpx.zero():Cpx.one(); } break;
              case "rect(": { inp[0].number=new Complex(num.absq()<0.25f?1:(num.absq()==0.25f?0.5f:0)); } break;
              
              //square wave, saw wave, triangle wave, rectangle
              
              case "!": { inp[0].number=Cpx2.factorial(num); } break;
              case "Γ(": { inp[0].number=Cpx2.gamma(num); } break;
              case "lnΓ(": { inp[0].number=Cpx2.loggamma(num); } break;
              case "ψ0(": case "ψ₀(": { inp[0].number=Cpx2.digamma(num); } break;
              case "K-Function(": { inp[0].number=Cpx3.kFunction(num,true); } break;
              case "Barnes-G(": { inp[0].number=Cpx3.barnesG(num); } break;
              
              case "erf(": { inp[0].number=Cpx2.erf(num); } break;
              case "erfi(": { inp[0].number=Cpx2.erfi(num); } break;
              case "erfc(": { inp[0].number=Cpx2.erfc(num); } break;
              case "erfcx(": { inp[0].number=Cpx2.erfcx(num); } break;
              case "FresnelC(": { inp[0].number=Cpx2.fresnelC(num); } break;
              case "FresnelS(": { inp[0].number=Cpx2.fresnelS(num); } break;
              
              case "ζ(": { inp[0].number=Cpx3.zeta(num); } break;
              case "η(": { inp[0].number=Cpx3.zeta(num).mul(Cpx.sub(1,new Complex(2).pow(Cpx.sub(1,num)))); } break;
              case "RS-Θ(": { inp[0].number=Cpx3.rsTheta(num); } break;
              case "RS-Z(": { inp[0].number=Cpx3.rsZFunction(num); } break;
              case "ξ(": { inp[0].number=Cpx.mul(num, num.sub(1), Cpx.pow(new Complex(Math.PI),num.mul(-0.5f)), Cpx3.gamma(num.mul(0.5f)), Cpx3.zeta(num)).muleq(0.5f); } break;
              
              case "Li₂(": case "Li2(": { inp[0].number=Cpx3.Li2(num); } break; //dilogarithm
              case "Cl₂(": case "Cl2(": { inp[0].number=Cpx3.Cl2(num); } break; //Clausen function
              
              case "Ein(": { inp[0].number=Cpx3.ein(num); } break;
              case "Ei(": { inp[0].number=Cpx3.ein(num).addeq(num.log()); } break;
              case "li(": { Complex ln = num.log(); inp[0].number=Cpx3.ein(ln).addeq(ln.ln()); } break;
              case "Si(": { inp[0].number=Cpx3.trigInt(num,false); } break;
              case "Ci(": { inp[0].number=Cpx3.trigInt(num,true).addeq(num.ln()).addeq(Mafs.GAMMA); } break;
              case "E₁(": case "E1(": { inp[0].number=Cpx3.ein(num.neg()).addeq(num.ln()).neg(); } break;
              case "Aux-f(": { inp[0].number=Cpx3.auxInt(num,true); } break;
              case "Aux-g(": { inp[0].number=Cpx3.auxInt(num,false); } break;
              
              case "EllipticK(": { inp[0].number=Cpx3.completeF(num); } break;
              
              ////// 2 INPUTS ///////
              
              case "rand(": {
                if(!num.isReal() || !inp[1].number.isReal()) { return new MathObj(new Complex(Double.NaN)); }
                inp[0].number=new Complex(Math.random()*(inp[1].number.re-num.re)+num.re);
              } break;
              case "randInt(": {
                if(!num.isReal() || !inp[1].number.isReal()) { return new MathObj(new Complex(Double.NaN)); }
                inp[0].number=new Complex(Math.round(Math.random()*(inp[1].number.re-num.re+1)+num.re-0.5f));
              } break;
              case "ψ(": {
                if(!num.isInt()) { return new MathObj("Cannot take ψ with non-integer modulus :("); }
                inp[0].number=Cpx3.polygamma2((int)num.re,inp[1].number);
              } break;
              case "nPr(": {
                inp[0].number=Cpx2.factorial(num).div(Cpx2.factorial(num.sub(inp[1].number)));
              } break;
              case "nCr(": {
                inp[0].number=Cpx2.factorial(num).div(Cpx2.factorial(inp[1].number).muleq(Cpx2.factorial(num.sub(inp[1].number))));
              } break;
              
              case "EllipticΠ(": case "EllipticPI(": { //this goes here for now, until I can figure out how to make the incomplete version
                inp[0].number=Cpx3.completePI(num,inp[1].number);
              } break;
              
              /*case "fuck(": {
                Complex sum = Cpx.zero();
                Complex pow = inp[0].number.mulI().exp();
                for(int n=0;n<=55;n++) { sum.addeq(pow.re/(1l<<n)); pow = pow.sq(); }
                inp[0].number = sum;
              } break;*/ //DEBUG
              
              /////// UNLIMITED INPUTS ////////
              
              case "max(": {
                double max = Double.NEGATIVE_INFINITY;
                for(MathObj m : inp) {
                  if(!m.number.isReal()) { inp[0].number = new Complex(Double.NaN); break; }
                  max = Math.max(m.number.re,max);
                }
                inp[0].number = new Complex(max);
              } break;
              case "min(": {
                double min = Double.POSITIVE_INFINITY;
                for(MathObj m : inp) {
                  if(!m.number.isReal()) { inp[0].number = new Complex(Double.NaN); break; }
                  min = Math.min(m.number.re,min);
                }
                inp[0].number = new Complex(min);
              } break;
              
              ///////// RECURSIVE FUNCTIONS ///////////////
              
              case "plug(": {
                String vari = e.links[0].tokens.get(0).id; //record the variable we're plugging into
                HashMap<String, MathObj> map2 = (HashMap<String,MathObj>)mapper.clone(); //clone the mapper
                map2.put(vari, inp[0].clone());        //plug variable in
                MathObj term = e.links[1].solve(map2); //solve
                inp[0].set(term);                      //set to the solution
              } break;
              
              case "Σ(": case "Π(": {
                if(inp[0].isNum() && inp[1].isNum()) { //if both bounds are valid:
                  
                  //TODO force the variable to be just a letter, not something weird and funky
                  String vari = e.links[0].tokens.get(0).id; //record the variable we're summing over
                  HashMap<String, MathObj> map2 = (HashMap<String,MathObj>)mapper.clone(); //clone the mapper
                  
                  Complex diff = inp[1].number.sub(inp[0].number); //compute difference
                  if(Math.abs(diff.im)>1e-6f || Math.abs(diff.re-Math.round(diff.re))>1e-6f) { inp[0].number = new Complex(Double.NaN); } //if separated by a non-integer amount, set result to NaN
                  diff.set(Math.round(diff.re)); //round to the nearest integer
                  boolean summer = id.equals("Σ(");
                  
                  Complex sum = summer ? Cpx.zero() : Cpx.one();
                  if(inp[1].number.re>=inp[0].number.re) { for(int n=0;n<=diff.re;n++) { //if the bounds go in a positive direction, add/multiply from first to last inclusive
                    map2.put(vari, new MathObj(inp[0].number.add(n))); //put current value in our mapper
                    MathObj term = e.links[1].solve(map2);             //solve function
                    if(summer) { sum.addeq(term.number); } //sum: add each term
                    else       { sum.muleq(term.number); } //product: multiply each term
                  } }
                  else { for(int n=-1;n>diff.re;n--) { //otherwise, subtract/divide from first to last backwards exclusive
                    map2.put(vari, new MathObj(inp[0].number.add(n))); //put current value in our mapper
                    MathObj term = e.links[1].solve(map2);             //solve function
                    if(summer) { sum.subeq(term.number); } //sum: subtract each term
                    else       { sum.muleq(term.number); } //product: multiply each term, then compute the reciprocal later (we could also divide each term, but this is faster)
                  } }
                  
                  if(summer || inp[1].number.re>=inp[0].number.re) { //if it's a sum, or we went in the positive direction:
                    inp[0].number = sum; //set the answer to the sum/product
                  }
                  else { inp[0].number = sum.inv(); } //otherwise, set it to the reciprocal
                }
                else { //otherwise:
                  inp[0].number = new Complex(Double.NaN); //set result to NaN
                }
              } break;
              
              ///////// OTHER ////////////
              
              case "Li(": {
                if(inp.length==1) { Complex ln = num.ln(); inp[0].number=Cpx3.ein(ln).add(ln.ln()).subeq(1.0451637801174928D); }
                if(inp.length==2) {
                  if(!num.isInt()) { return new MathObj("Cannot take polylogarithm with non-integer modulus :("); }
                  inp[0].number=Cpx3.polylog((int)num.re,inp[1].number);
                }
              } break;
              case "EllipticF(": {
                if(inp.length==1) { inp[0].number=Cpx3.completeF(num); }
                if(inp.length==2) { inp[0].number=Cpx3.incompleteF(num,inp[1].number); }
              } break;
              case "EllipticE(": {
                if(inp.length==1) { inp[0].number=Cpx3.completeE(num); }
                if(inp.length==2) { inp[0].number=Cpx3.incompleteE(num,inp[1].number); }
              } break;
            }
          }
          
          else if(allBools) {
            switch(id) {
              case "&":            inp[0].bool &= inp[1].bool; break;
              case "|":            inp[0].bool |= inp[1].bool; break;
              case "^": case "!=": inp[0].bool ^= inp[1].bool; break;
              case "=": case "==": inp[0].bool ^= !inp[1].bool; break;
              
              case "&&": if(inp[0].bool) { inp[0].bool = e.links[0].solve(mapper).bool; } break;
              case "||": if(!inp[0].bool) { inp[0].bool = e.links[0].solve(mapper).bool; } break;
            
              default: return new MathObj("Error: cannot perform boolean "+e.getId()+" boolean");
            }
          }
          
          for(int n=0;n<e.inps-1;n++) { out.remove(out.size()-1); } //remove the last commaCount elements
        } break;
      }
    }
    return out.get(0);
  }
  
  
  
  
  
  public static String[] funcList = largestToSmallest(new String[] {"(","√(","ln(","log(","abs(","arg(","Re(","Im(","conj(","sgn(","abs2(","abs²(","csgn(",
          "sin(","cos(","tan(","sec(","csc(","cot(","sinh(","cosh(","tanh(","sech(","csch(","coth(",
          "sin⁻¹(","cos⁻¹(","tan⁻¹(","sec⁻¹(","csc⁻¹(","cot⁻¹(","sinh⁻¹(","cosh⁻¹(","tanh⁻¹(","sech⁻¹(","csch⁻¹(","coth⁻¹(",
          "asin(","acos(","atan(","asec(","acsc(","acot(","asinh(","acosh(","atanh(","asech(","acsch(","acoth(",
          "floor(","ceil(","round(","frac(","GCF(","LCM(","max(","min(","SqrWave(","SawWave(","TriWave(","rect(","θ(",
          "nCr(","nPr(","rand(","randInt(","Γ(","lnΓ(","ψ₀(","ψ0(","ψ(","K-Function(","Barnes-G(","erf(","erfi(","erfc(","erfcx(","FresnelC(","FresnelS(",
          "ζ(","η(","RS-Θ(","RS-Z(","ξ(", "Li₂(","Li2(","Cl₂(","Cl2(","Li(", "Ein(","Ei(","li(","Si(","Ci(","E₁(","E1(","Aux-f(","Aux-g(",
          "EllipticK(","EllipticF(","EllipticE(","EllipticΠ(","EllipticPI(","Σ(","Π(","∫(","d/dx(","d²/dx²(","root(","plug("/*,"fuck("*/});

  public static String[] varList = largestToSmallest(new String[] {"Ans","true","false","π","e","γ","i"});
  
  public static int minInps(String func) { //minimum number of inputs a function can have
    switch(func) {
      case "GCF(": case "LCM(": case "max(": case "min(":                 return 0; //any # of inputs
      case "rand(": case "randInt(": case "ψ(": case "nCr(": case "nPr(": return 2; //these take exactly 2 inputs
      case "Li(": case "EllipticF(": case "EllipticE(":                   return 1; //can take 1 or 2 inputs
      case "EllipticΠ(": case "EllipticPI(":                              return 2; //can take 2 or 3 inputs
      
      case "plug(":         return 3; //takes 3 inputs
      case "Σ(": case "Π(": return 4; //takes 4 inputs
      
      default: return 1; //most functions accept exactly 1 input
    }
  }
  
  public static int maxInps(String func) { //maximum number of inputs a function can have
    switch(func) {
      case "GCF(": case "LCM(": case "max(": case "min(":                 return Integer.MAX_VALUE; //any # of inputs
      case "rand(": case "randInt(": case "ψ(": case "nCr(": case "nPr(": return 2;                 //these take exactly 2 inputs
      case "Li(": case "EllipticF(": case "EllipticE(":                   return 2;                 //can take 1 or 2 inputs
      case "EllipticΠ(": case "EllipticPI(":                              return 2;                 //can take 2 or 3 inputs (should be able to take 3, but that hasn't been programmed in yet)
      
      case "plug(":         return 3; //takes 3 inputs
      case "Σ(": case "Π(": return 4; //takes 4 inputs
      
      default: return 1; //most functions accept exactly 1 input
    }
  }
  
  //ASSERTION: the outputted array must (MUST) be sorted, least to greatest
  public static int[] recursiveCheck(String func) { //given a function, this'll tell us which indices of its input set corresponds to which link
    switch(func) {
      case "&&": case "||": return new int[] {1}; //&& and ||: link 0 is input 1 (not input 0)
      case "Σ(": case "Π(": return new int[] {0,3}; //sum and product: link 0 is input 0, link 1 is input 3 (variable, start, end, equation)
      case "plug(":         return new int[] {0,2}; //plug: link 0 is input 0, link 1 is input 2 (variable, value, equation)
      
      case "?": return new int[] {1}; //to make the ternary operator work, we have to do a little trickery. First, putting the first option into the ?'s link, then replacing : with ?:, then putting both into ?:'s links
      
      default: return new int[] {}; //for most functions, though, there aren't any links
    }
  }
  
  public static String[] largestToSmallest(String[] inp) { //sort strings largest to smallest
    for(int i=1;i<inp.length;i++) { //loop through all elements
      int len = inp[i].length();    //record string length
      for(int j=i;j>0;j--) {        //loop through all strings before this
        if(len>inp[j-1].length()) { String temp = inp[j]; inp[j]=inp[j-1]; inp[j-1]=temp; } //if out of order, swap
        else { break; }             //otherwise, exit j loop
      }
    }
    return inp; //return result
  }
}
enum GraphMode {
  RECT2D, POLAR, PARAMETRIC2D, RECT3D, CYLINDRICAL, SPHERICAL, PARAMETRIC3D, NONE;
  
  public int graphDim() { return this==RECT2D || this==POLAR || this==PARAMETRIC2D ? 2 : 3; }
  public int inps() { return graphDim()==2 ? 1 : 2; }
  public int outs() { return this==PARAMETRIC2D ? 2 : this==PARAMETRIC3D ? 3 : 1; }
  
  public String[] inputs() { switch(this) {
    case RECT2D: return new String[] {"x"};
    case POLAR: return new String[] {"θ"};
    case PARAMETRIC2D: return new String[] {"t"};
    case RECT3D: return new String[] {"x","y"};
    case CYLINDRICAL: return new String[] {"r","θ"};
    case SPHERICAL: return new String[] {"θ","φ"};
    case PARAMETRIC3D: return new String[] {"t","u"};
    default: return new String[0];
  } }
  
  public String piButton() { switch(this) {
      case NONE: return "π";
      case RECT2D: case RECT3D: return "x π";
      case POLAR: case CYLINDRICAL: case SPHERICAL: return "θ π";
      case PARAMETRIC2D: case PARAMETRIC3D: return "t π";
      default: return null;
  } }
  
  public String eButton() { switch(this) {
    case NONE: case RECT2D: case POLAR: case PARAMETRIC2D: return "e E";
    case RECT3D: return "y e";
    case CYLINDRICAL: return "r e";
    case SPHERICAL: return "φ e";
    case PARAMETRIC3D: return "u e";
    default: return null;
  } }
}

public class Graphable { //graphable function
  public int stroke = 0xFFFF8000;
  public int strokeWeight = 2;
  public GraphMode mode = GraphMode.RECT2D;
  public boolean visible = true;
  
  public double start=-Math.PI, end=Math.PI; //TODO make it so this can be a function of our graph position/scale
  public int steps = 1000;
  
  Equation[] functions; //array of equations that map the input to the output
  
  Graphable(int col, Equation... equat) {
    stroke=col;
    functions=new Equation[equat.length];
    for(int n=0;n<equat.length;n++) { functions[n]=equat[n]; }
  }
  
  public void setVisible(boolean vis) { visible=vis; }
  
  //public int step = 1; //step size
}

public class Graph { //an object which can graph things out
  
  ////////// ATTRIBUTES //////////////
  
  double origX, origY;    //the pixel position of the origin on the pgraphics object
  double pixPerUnit;      //the number of pixels in a single unit length
  float tickLen=0.06666667f*width; //the length of the tick lines, in pixels
  boolean visible = true; //whether the graph is visible
  
  ///////// CONSTRUCTORS /////////////
  
  Graph(double x, double y, double s) { origX=x; origY=y; pixPerUnit=s; } //constructor w/ attributes
  
  ////////// GETTERS/SETTERS ////////////////
  
  public Graph setVisible(boolean vis) { visible=vis; return this; }
  
  
  /////////////////// DISPLAY ////////////////////
  
  public void display(PGraphics pgraph, float x, float y, float wid, float hig, ArrayList<Graphable> plots) {
    if(!visible) { return; } //if invisible, quit
    
    drawGridLines(pgraph, x, y, wid, hig);
    
    graph2D(pgraph, x,y,wid,hig,plots);
  }
  
  public void drawGridLines(PGraphics pgraph, float xt, float yt, float wid, float hig) { //sets up the graph by drawing all the gridlines
    //Step 1: Find how far apart each gridline should be
    //First, note the desired behavior. At original scale, each tick mark will be 1 apart. Then, as we zoom out, it'll be 2 apart. Then 5, then 10, then 20, 50, 100, 200, 500, 1000, etc.
    //The rule of thumb is to have their distance be the smallest they can be while still being at least hig/12 pixels apart. Without the above rule, that would make our tick size hig/(12*pixPerUnit) units apart
    
    //Since this is on a base 10 logarithmic scale, a logical first step would be to take the base 10 logarithm of our hypothetical tick size
    double log = Math.log(hig/(12.0f*pixPerUnit))/Math.log(10); //according to our rule, the tick size should be >= 10^log
    double ceil = Math.ceil(log), frac = ceil-log; //record the ceiling of the log, as well as the fractional difference. Our tick size should either be 10^ceil, 1/2*10^ceil, or 1/5*10^ceil.
    String ticAsString;   //to get an EXACT decimal tick size w/out roundoff, we'll compute the tick size as a string then cast to a double
    double splitSize; //we'll also be drawing fainter lines between the ticks, and we also need to compute the distance between those. But they don't need to be as accurate
    int splitPerTick; //number of splitter lines per tick
    if     (frac<Math.log(2)/Math.log(10)) { ticAsString = "1E"+(long)ceil;     splitPerTick = 5; } //0 <= frac < log10(2): 10^ceil
    else if(frac<Math.log(5)/Math.log(10)) { ticAsString = "5E"+(long)(ceil-1); splitPerTick = 5; } //log10(2) <= frac < log10(5): 10^ceil / 2
    else                                   { ticAsString = "2E"+(long)(ceil-1); splitPerTick = 4; } //log10(5) <= frac < 1: 10^ceil / 5
    
    double tickSize = Double.valueOf(ticAsString); //cast string to double, now we have the tick size
    splitSize = tickSize/splitPerTick;             //compute split size
    
    //Step 2: Find where to draw the first & last gridlines. You should overshoot in all directions, so that the splitters between them don't disappear right before the edge of the screen.
    long xStart = (long)Math.floor(    -origX /(pixPerUnit*tickSize)), //which multiple of tickSize to start with in the x direction
         xEnd   = (long)Math.ceil ((wid-origX)/(pixPerUnit*tickSize)), //which multiple to end with
         yStart = (long)Math.floor((origY-hig)/(pixPerUnit*tickSize)),  //same in the y direction, but different because up/down are reversed on screens
         yEnd   = (long)Math.ceil ( origY     /(pixPerUnit*tickSize)); //same in the y direction
    
    //Step 3: Draw the splitter lines between each tick
    pgraph.stroke(24); pgraph.strokeWeight(2); //set the drawing parameters
    for(long x=xStart;x<xEnd;x++) {     //loop through all ticks in the x direction
      for(int n=0;n<splitPerTick;n++) { //draw the 4-5 splitters
        pgraph.line(xt+(float)(origX+(x*tickSize+n*splitSize)*pixPerUnit),yt,xt+(float)(origX+(x*tickSize+n*splitSize)*pixPerUnit),yt+hig); //draw the vertical splitter lines
      }
    }
    for(long y=yStart;y<yEnd;y++) {     //now, just do the same thing in the y direction
      for(int n=0;n<splitPerTick;n++) { //draw the 4-5 splitters
        pgraph.line(xt,yt+(float)(origY-(y*tickSize+n*splitSize)*pixPerUnit),xt+wid,yt+(float)(origY-(y*tickSize+n*splitSize)*pixPerUnit)); //draw the horizontal splitter lines
      }
    }
    
    //Step 4: Draw the axes
    pgraph.stroke(255); pgraph.strokeWeight(2); //set the drawing parameters
    line(xt,yt+(float)origY,xt+wid,yt+(float)origY); //draw the x-axis
    line(xt+(float)origX,yt,xt+(float)origX,yt+hig); //draw the y axis
    
    //Step 5: Draw the ticks along each axis
    float xCut=constrain((float)origX,0,wid), yCut=constrain((float)origY,0,hig); //the tick marks should be displayed, regardless of if the axes are on screen. Here are their positions on screen
    for(long x=xStart;x<xEnd;x++) { //loop through all ticks in the x direction
      if(x!=0) { pgraph.line(xt+(float)(origX+x*tickSize*pixPerUnit),yt+yCut-0.5f*tickLen,xt+(float)(origX+x*tickSize*pixPerUnit),yt+yCut+0.5f*tickLen); } //draw each tick at appropriate lengths
    }
    for(long y=yStart;y<yEnd;y++) { //loop through all ticks in the y direction
      if(y!=0) { pgraph.line(xt+xCut-0.5f*tickLen,yt+(float)(origY-y*tickSize*pixPerUnit),xt+xCut+0.5f*tickLen,yt+(float)(origY-y*tickSize*pixPerUnit)); } //draw each tick at appropriate lengths
    }
    
    //Step 5: Label each tick mark
    boolean topOrBottom = origY>hig-tickLen, leftOrRight = origX>tickLen; //decide on which side of each axis the labels are gonna go
    
    pgraph.textAlign(CENTER,topOrBottom ? BOTTOM : TOP);
    for(long x=xStart;x<xEnd;x++) { //loop through all ticks in the x direction
      if(x==0) { continue; }
      String label = new Complex(x*tickSize).toString(12);
      float sizer = io.getTextWidth(label,20); pgraph.textSize(min(0.04444f*width,(float)(20*0.9f*tickSize*pixPerUnit/sizer))); //set the textSize so that text does not overlap
      pgraph.text(label,xt+(float)(origX+x*tickSize*pixPerUnit),yt+yCut-(topOrBottom?0.625f:-0.625f)*tickLen);
    }
    
    textSize(0.04444f*width);
    pgraph.textAlign(leftOrRight ? RIGHT : LEFT, CENTER);
    for(long y=yStart;y<yEnd;y++) { //loop through all ticks in the x direction
      if(y==0) { continue; }
      String label = new Complex(y*tickSize).toString(12);
      pgraph.text(label,xt+xCut-(leftOrRight?0.625f:-0.625f)*tickLen,yt+(float)(origY-y*tickSize*pixPerUnit));
    }
  }
  
  public void graph2D(PGraphics pgraph, float xt, float yt, float wid, float hig, ArrayList<Graphable> gr) {
    for(Graphable f : gr) {
      graph2D(pgraph,xt,yt,wid,hig,f);
    }
  }
  
  public void graph2D(PGraphics pgraph, float xt, float yt, float wid, float hig, Graphable f) {
    if(!visible || !f.visible) { return; } //if the graph or graphable isn't visible, quit
    for(Equation eq : f.functions) { if(eq.isEmpty()) { return; } } //if any of the equations are empty, we quit. Don't attempt to graph
    
    pgraph.stroke(f.stroke); pgraph.strokeWeight(f.strokeWeight); pgraph.noFill(); //set drawing parameters
    
    graph2DFunc(pgraph, xt, yt, wid, hig, f); //use method for plotting it out
    
    /*switch(f.mode) {
      case RECT2D: graphRect2D(pgraph, xt, yt, wid, hig, f); break;
      case POLAR: graphPolar(pgraph, xt, yt, wid, hig, f); break;
      case PARAMETRIC2D: break;
    }*/
  }
  
  public void graph2DFunc(PGraphics pgraph, float xt, float yt, float wid, float hig, Graphable f) { //graphs the given 2D function
    HashMap<String, MathObj> feed = new HashMap<String, MathObj>(); //is fed into the solve function
    boolean works, worked=false; //whether this current point is plottable, whether the previous point was plottable
    
    double stepSize = (f.mode==GraphMode.RECT2D) ? 1d/pixPerUnit : (f.end-f.start)/f.steps; //how much the input increases by each iteration
    int steps = (f.mode==GraphMode.RECT2D) ? round(wid) : f.steps;
    
    double cos=0, sin=0, cosStep=0, sinStep=0; //used only for making polar graphs easier
    if(f.mode==GraphMode.POLAR) { cos=Math.cos(f.start); sin=Math.sin(f.start); cosStep=Math.cos(stepSize); sinStep=Math.sin(sinStep); }
    
    pgraph.beginShape(); //begin connecting the dots
    for(int n=0;n<=steps;n++) { //loop through all x values
      
      double inp = (f.mode==GraphMode.RECT2D) ? (n-origX)*stepSize : n*stepSize+f.start; //compute current input
      
      feed.put(f.mode.inputs()[0],new MathObj(new Complex(inp))); //tell the solver to plug in this value for x/θ/t
      MathObj[] out = new MathObj[f.functions.length];            //initialize the output
      works = true;                                                 //init works to true
      for(int k=0;k<out.length;k++) {
        out[k] = f.functions[k].solve(feed); //compute each of the outputs
        works &= works && out[k].isNum() && out[k].number.isReal() && Float.isFinite((float)out[k].number.re); //this point is plottable if all outputs are numbers, real, and finite when cast to a float
      }
      //TODO give slight leeway for numbers with very small imaginary part, adjust algorithm so odd vertical asymptotes don't get connected
      
      if(works) { //if point is plottable:
        if(!worked) { pgraph.beginShape(); } //if previous point wasn't plottable, begin shape
        
        switch(f.mode) {
          case RECT2D: {
            double y = out[0].number.re; //find point to plot
            pgraph.vertex(xt+n,yt+(float)(origY-y*pixPerUnit)); //plot it
          } break;
          
          case POLAR: {
            double r = out[0].number.re; //find point to plot
            pgraph.vertex(xt+(float)(r*cos),yt-(float)(r*sin)); //plot it
          } break;
        }
      }
      else if(worked) { pgraph.endShape(); } //otherwise, if the previous point was plottable, end shape
      
      if(f.mode==GraphMode.POLAR) { double cos2 = cos; cos = cos*cosStep - sin*sinStep; sin = cos2*sinStep + sin*cosStep; } //if in polar mode, use this angle addition formula each iteration to avoid using too much trig
      
      worked = works; //set worked to works
    }
    pgraph.endShape(); //end connecting the dots
  }
  
  ////////////////// UPDATES /////////////////
  
  public void updateFromTouches(Mmio mmio, float xt, float yt) { //uses MMIO's cursors & mouse wheel to update shift & scale
    if(!visible) { return; } //if not visible, don't interact
    
    ArrayList<Cursor> interact = new ArrayList<Cursor>(); //arraylist of all cursors which are interacting with the graph
    for(Cursor curs : mmio.cursors) { //loop through all cursors
      if(curs.anyPressed() && (curs.getSelect()==null || curs.getSelect() instanceof Mmio)) { interact.add(curs); } //add all cursors which are pressing and are selecting nothing (or selecting the MMIO)
    }
    
    if(interact.size()==1) { //if exactly one cursor is touching it, we only translate:
      origX += interact.get(0).x - interact.get(0).dx; //shift x by delta x
      origY += interact.get(0).y - interact.get(0).dy; //shift y by delta y
    }
    else if(interact.size()==2) { //(Android only) if exactly 2 cursors are touching it, we translate AND scale:
      Cursor c0 = interact.get(0), c1 = interact.get(1); //load both cursors
      
      //1: scale
      float ratio = sqrt((sq(c0.x-c1.x)+sq(c0.y-c1.y))/(sq(c0.dx-c1.dx)+sq(c0.dy-c1.dy))); //compute the ratio between the distance between both cursors before & after
      pixPerUnit *= ratio; //the size of a unit (in pixels) expands by this ratio
      
      //2: translate. This has to be done in steps
      origX-=0.5f*(c0.dx+c1.dx); origY-=0.5f*(c0.dy+c1.dy); //1 un-translate by previous midpoint
      origX*=ratio; origY*=ratio;                         //2 scale up by the scale factor
      origX+=0.5f*(c0.x+c1.x); origY+=0.5f*(c0.y+c1.y);     //3 re-translate by current midpoint
    }
    
    if(mmio.wheelEventX!=0 || mmio.wheelEventY!=0) { //(PC only) if the mousewheel has moved, we translate AND scale:
      Cursor curs = mmio.cursors.get(0); //load the cursor (it's PC, so there's exactly 1 cursor: the mouse)
      
      //1: scale
      float scale = pow(1.1f,-mmio.wheelEventY-2*mmio.wheelEventX); //compute the amount by which we scale up/down
      pixPerUnit *= scale; //the size of a unit (in pixels) expands by this scale factor
      
      //2: translate. This has to be done in steps
      origX-=curs.x-xt; origY-=curs.y-yt; //1 un-translate by mouse position
      origX*=scale; origY*=scale;         //2 scale up by the scale factor
      origX+=curs.x-xt; origY+=curs.y-yt; //3 re-translate by mouse position
    }
  }
}

/*public class Graph {
  float transX, transY; //the translation of the graph (we'll figure out what that is later)
  float scale; //the zoom scale of the graph (we'll figure out what it is later)
  float tic = 30; //I'll figure out what this is later
  
  void setUpGraph(int wid, int hig) { //draws all the gridlines on the graph
    double log=Math.log(hig*scale/12.0)/Math.log(10); //here, we label the x & y axes with multiples of either 1, 2, 5, 10, 20, 50, 100, 200, 500, etc.  This algorithm figures out which one to use.
    double incr=Math.min(Math.min(Math.pow(10D,Math.ceil(log)), 2*Math.pow(10D,Math.ceil(log-Math.log(2)/Math.log(10)))), 5*Math.pow(10D,Math.ceil(log-Math.log(5.0)/Math.log(10))));
    //there's probably a better way to do this, but I haven't done it because there's no guarantee there is one, and if there is, it could actually be less intuitive
    
    double ticSiz=incr/scale;                        //size of each tick mark in pixels
    double xStart=((int)(-(transX)/ticSiz))*incr;    //first tick mark on the x-axis
    double yStart=((int)((transY-hig)/ticSiz))*incr; //first tick mark on the y-axis
    double xPosStart=transX%ticSiz;                  //pixel position of first tick mark on the x-axis
    double yPosStart=(transY-hig)%ticSiz+hig;        //pixel position of first tick mark on the y-axis
  
    //transX+((int)(-scale*(transX)/incr))*incr/scale
    //transX-(int)(scale*transX/incr)*incr/scale
    //transX%(incr/scale)
   
    //transY-((int)(scale*(transY-Height)/incr))*incr/scale
    //transY-Height-(int)(scale*(transY-Height)/incr)*incr/scale+Height
    //(transY-Height)%(incr/scale)+Height
    
    stroke(48);
    strokeWeight(2);
    
    for(int n=-5;n<50;n++) { line((float)(xPosStart+0.2*n*ticSiz),0,(float)(xPosStart+0.2*n*ticSiz),hig); }
    for(int n=-5;n<65;n++) { line(0,(float)(yPosStart-0.2*n*ticSiz),wid,(float)(yPosStart-0.2*n*ticSiz)); }
  
    stroke(255);fill(255); textSize(45);
    line(0,(float)transY, wid,(float)transY); //draw the x axis
    line((float)transX,0,(float)transX,hig); //draw the y axis
    
    boolean toporbottom = (transY+30)>hig;
    textAlign(CENTER,toporbottom?BOTTOM:TOP);
  
    for(int n=-1;n<=10;n++) { //draw all the tick marks on the x axis
      line((float)(xPosStart+n*ticSiz),constrain((float)(transY-tic),0,hig-tic),(float)(xPosStart+n*ticSiz),constrain((float)(transY+tic),tic,hig));
      if(xStart+incr*n != 0) { text(Mafs.str(xStart+incr*n,12), (float)(xPosStart+n*ticSiz),constrain((float)(transY),0,hig)+(toporbottom?-45:45)); }
    }
    
    boolean leftorright = (transX<40);
    textAlign(leftorright?LEFT:RIGHT,CENTER);
   
    for(int n=0;n<=12;n++) { //draw all the tick marks on the y axis
      line(constrain((float)(transX-tic),0,wid-tic),(float)(yPosStart-n*ticSiz),constrain((float)(transX+tic),tic,wid),(float)(yPosStart-n*ticSiz));
      if(yStart+incr*n != 0) { text(Mafs.str(yStart+incr*n,12), constrain((float)(transX),0,wid)+(leftorright?45:-45),(float)(yPosStart-n*ticSiz)); }
    }
  }
  
  void graph2D(Graphable f, int wid, int hig) {
    double inp; //instantiate input
    Complex[] out=new Complex[f.mode.outDim()]; //instantiate output(s)
    
    double xCurr=-1, xPrev=-1;         //current & previous x coordinate on the graph
    double yCurr=-1, yPrev=-1;         //current & previous y coordinate on the graph
    boolean works=false, worked=false; //whether or not the current & previous coordinates were graphable
    
    stroke(f.stroke); //set stroke
    strokeWeight(f.strokeWeight);
    noFill();         //don't fill
    
    int lMin=-128, lMax=128; //min & max step
    double inpScale, offset; //how much to scale & offset input
    
    double[] angle={1,0}, step={1,0}; //sin & cos of angle & step size
    
    double scaleInv = 1d/scale; //precompute 1/scale to save divisions
    
    switch(f.mode) {
      case RECT:
        lMin=0; lMax = wid/f.step;                   //set loop bounds
        inpScale=f.step*scale; offset=-scale*transX; //set scale & offset
      break;
      case POLAR:
        lMin = -128; lMax = 128;
        inpScale=Math.PI/64; offset=0;
        angle = new double[] {Mafs.cos(lMin*inpScale+offset), Mafs.sin(lMin*inpScale+offset)};
        step = new double[] {Mafs.cos(inpScale), Mafs.sin(inpScale)};
      break;
      case PARAMETRIC:
        lMin = -128; lMax = 128;
        inpScale = 1d/32; offset=0;
      break;
      default:
        inpScale=1; offset = 0;
    }
    
    for(int n2=lMin;n2<=lMax;n2++) { //loop through every input
      
      inp=inpScale*n2+offset;        //set our input equal to where we are in the loop, shifted and scaled
      out = f.function(new Complex(inp)); //find output
      
      yPrev=yCurr;  //set the previous y equal to the current y
      xPrev=xCurr;  //same goes for x
      worked=works; //set the previous works to the current works
      
      works=true;
      for(Complex c: out) {
        if(c.re*0.0!=c.re*0.0 || Math.abs(c.im)>1e-12d) { //if any of the outputs are non-real or undefined:
          works=false; break;                             //works is false (this doesn't work), exit the loop
        }
      }
      
      if(!works) { xCurr = yCurr = -1; }
      else switch(f.mode) {
        case RECT:
          xCurr = f.step*n2;
          yCurr = transY-out[0].re*scaleInv;
        break;
        case POLAR:
          xCurr = transX+out[0].re*angle[0]*scaleInv;
          yCurr = transY-out[0].re*angle[1]*scaleInv;
          
          double sto = angle[0];
          angle[0]=sto*step[0]-angle[1]*step[1];
          angle[1]=sto*step[1]+angle[1]*step[0];
        break;
        case PARAMETRIC:
          xCurr = transX+out[0].re*scaleInv;
          yCurr = transY-out[1].re*scaleInv;
        break;
      }
      
      if((xCurr>=0 && xCurr<=wid && yCurr>=0 && yCurr<=hig) || (xPrev>=0 && xPrev<=wid && yPrev>=0 && yPrev<=hig)) { //if the current or previous point was on screen, then we can draw something
        
        if(xPrev<0 || yPrev<0 || xPrev>wid || yPrev>hig) { //if the previous point was off screen,
          beginShape(); //begin drawing
            if(worked) { //if it the previous point was still valid, just off screen:
              if     (yPrev<0  ) { vertex((float)(xCurr-yCurr*(xCurr-xPrev)/(yCurr-yPrev)) , 0);        } //draw a line connecting this point to the next one
              else if(xPrev<0  ) { vertex(0 , (float)(yCurr-xCurr*(yCurr-yPrev)/(xCurr-xPrev)));        }
              else if(yPrev>hig) { vertex((float)(xCurr+(xCurr-xPrev)*(hig-yCurr)/(yCurr-yPrev)), hig); }
              else               { vertex(wid, (float)(yCurr+(yCurr-yPrev)*(wid-xCurr)/(xCurr-xPrev))); }
            }
          }
         
          if(xCurr>=0 && yCurr>=0 && xCurr<=wid && yCurr<=hig) { vertex((float)xCurr, (float)yCurr); } //if the current point is visible, plot it out
         
          else {        //otherwise,
            if(works) { //if this point is still valid, but goes off screen:
              if     (yCurr<0  ) { vertex((float)(xCurr-yCurr*(xCurr-xPrev)/(yCurr-yPrev)) , 0);        } //draw a line connecting the previous point to this one
              else if(xCurr<0  ) { vertex(0 , (float)(yCurr-xCurr*(yCurr-yPrev)/(xCurr-xPrev)));        }
              else if(yCurr>hig) { vertex((float)(xCurr+(hig-yCurr)*(xCurr-xPrev)/(yCurr-yPrev)), hig); }
              else               { vertex(wid, (float)(yCurr+(wid-xCurr)*(yCurr-yPrev)/(xCurr-xPrev))); }
            }
            endShape(); //end the plot
          }
        }
      }
      endShape(); //end the plot
  }
}*/
//TODO Add persistent memory. Namely, make it so the calculator remembers your QA history and the equations you had up

public void interfaceInit(final Mmio io) {
  //Here, we have a bunch of spaghetti code used for initializing the entire user interface. Enjoy/I'm sorry.
  
  io.setSurfaceFill(0x00FFFFFF).setSurfaceDims(width,height).setPos(0,0).setDims(width,height); //initialize the entire surface
  
  //here is where we would load all the memory from storage, if that was implemented
  
  //put special sizing variables here, so they can be changed at a whim
  final float topHig = 0.05555556f*height;
  final float lrBuff = 0.011111f*width, topBuff=0.011111f*height, historyHig = 0.46666667f*height, inpHig = 0.05555556f*height;
  final float inpBuffX=0.02222f*width, inpBuffY=0.007778f*height;
  final float addButtHig=0.05f*height;
  final float equationHeight=0.05555556f*height;
  final float thick1=0.0066667f*width, thick2=0.002222f*width, thick3=0.004444f*width;
  
  Button palette = new Button(0,0,0,0).setFills(0xFF001818,0xFF003030,0xFF006060).setStrokes(0xFF008080); //a placeholder button we can steal the palette from
  
  //3 buttons at the top to swap between calculator modes
  Button  calcMode = (Button)new Button(        0,0,width/3,topHig).setFills(0xFF000080,0xFF0000FF).setStrokes(0xFF8080C0,0xFF8080FF).setStrokeWeight(thick1).setParent(io).setText("Calculator",0xFF8080FF),
         equatMode = (Button)new Button(  width/3,0,width/3,topHig).setFills(0xFF000080,0xFF0000FF).setStrokes(0xFF8080C0,0xFF8080FF).setStrokeWeight(thick1).setParent(io).setText("Equations",0xFF8080FF),
         graphMode = (Button)new Button(2*width/3,0,width/3,topHig).setFills(0xFF000080,0xFF0000FF).setStrokes(0xFF8080C0,0xFF8080FF).setStrokeWeight(thick1).setParent(io).setText("  Graph  ",0xFF8080FF);
  
  //This right here is a vertically-scrollable panel that shows the question/answer history.
  initializeHistoryDisplay(lrBuff, topHig, topBuff, historyHig, inpBuffX, inpBuffY, thick1, thick2, inpHig);
  
  // Now, we implement the screen that lets us enter all the graphable equations
  
  equatHolder = new Panel(lrBuff,topHig+topBuff,width-2*lrBuff,historyHig+inpHig,width-2*lrBuff,historyHig+inpHig); equatHolder.setSurfaceFill(0).setStroke(0xFF00FFFF).setParent(io).setActive(false);
  
  initializeEquationList(palette, addButtHig, equationHeight, thick2, inpBuffY);
  
  // Now, we implement the keypad that lets us type in all our equations
  
  float buttTop = inputField.y+inputField.h+topBuff;
  
  keyPad = new Panel(0,buttTop,width,height-buttTop, width,height-buttTop); keyPad.setSurfaceFill(0).setStroke(false).setParent(io);
  
  initializeKeypad(topBuff, palette, thick3);
  
  
  
  //now, we tell the 3 buttons at the top what to do
  calcMode.setOnRelease(new Action() { public void act() {
    historyShow.setActive(true);
    inputField.setActive(true);
    keyPad.setActive(true);
    keypadMode = GraphMode.NONE;
    equatHolder.setActive(false);
    io.setTyper(inputField); equationCache=null;
    grapher.setVisible(false);
    disableTestVars();
    
    boolean on = true;
    for(Box b : keyPad) { if(b.text[0].getText().equals("x π")) { on=b.active; b.setActive(false); break; } }
    if(on) { for(Box b : keyPad) { if(b.text[0].getText().equals("π")) { b.setActive(true); break; } } }
  } });
  equatMode.setOnRelease(new Action() { public void act() {
    historyShow.setActive(false);
    inputField.setActive(false);
    keyPad.setActive(true);
    keypadMode = GraphMode.RECT2D;
    equatHolder.setActive(true);
    io.setTyper(null); equationCache=null; updateColorSelector();
    grapher.setVisible(false);
    disableTestVars();
    
    boolean on = true;
    for(Box b : keyPad) { if(b.text[0].getText().equals("π")) { on=b.active; b.setActive(false); break; } }
    if(on) { for(Box b : keyPad) { if(b.text[0].getText().equals("x π")) { b.setActive(true); break; } } }
  } });
  graphMode.setOnRelease(new Action() { public void act() {
    historyShow.setActive(false);
    inputField.setActive(false);
    keyPad.setActive(false);
    equatHolder.setActive(false);
    io.setTyper(null); equationCache=null;
    grapher.setVisible(true);
    disableTestVars();
  } });
  
  /*new Button(lrBuff,buttTop,buttWid,buttHig).setOnRelease(new Action() { public void act() { if(io.typer!=null) { io.typer.readInput(InputCode.LEFT); } } })
  .setPalette(palette).setParent(io).setText("◄",#00FFFF);
  new Button(lrBuff+buttWid,buttTop,buttWid,buttHig).setOnRelease(new Action() { public void act() { if(io.typer!=null) { io.typer.readInput(InputCode.RIGHT); } } })
  .setPalette(palette).setParent(io).setText("►",#00FFFF);*/
  //►
}

public void initializeHistoryDisplay(final float lrBuff, final float topHig, final float topBuff, final float historyHig, final float inpBuffX, final float inpBuffY, final float thick1, final float thick2, final float inpHig) {
  final float entryHig=0.044444f*height; int entries = 128;
  final float historyTextSize = 0.017f*height;
  
  historyShow = new Panel(lrBuff,topHig+topBuff,width-2*lrBuff,historyHig,width-2*lrBuff,2*entryHig*entries); historyShow.setSurfaceFill(0).setStroke(0xFF00FFFF).setParent(io);
  historyShow.setPixPerClick(10); historyShow.setScrollY(historyShow.h-historyShow.surfaceH); historyShow.setDragMode(DragMode.NONE,DragMode.NORMAL);
  for(int n=0;n<entries;n++) {
    final Textbox quest = (Textbox)new Textbox(0,2*n*entryHig,width-2*lrBuff,entryHig).setTextColor(0xFF00FFFF).setTextSizeAndAdjust(historyTextSize).setScrollable(false,false).setSurfaceFill(0xFF000000).setStroke(0xFF00FFFF).setParent(historyShow);
    quest.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
      String type = quest.getText();
      io.typer.readInput(new InputCode(new int[] {'I',0,'S',type.length()}, new String[] {type}));
    } } });
    
    final Button ans = (Button)new Button(0,(2*n+1)*entryHig,width-2*lrBuff,entryHig).setFills(0xFF000000).setStrokes(0xFF00FFFF).setParent(historyShow).setText(new Text("",width-3*lrBuff,0.5f*entryHig,historyTextSize,0xFF00FFFF,RIGHT,CENTER));
    ans.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
      String type = ans.text[0].getText(); if(!type.equals("")) { type = "("+type+")"; }
      io.typer.readInput(new InputCode(new int[] {'I',0,'S',type.length()}, new String[] {type}));
    } } });
  }
  
  inputField = new Textbox(lrBuff,topHig+topBuff+historyHig,width-2*lrBuff,inpHig).setTextColor(0xFF00FFFF).setCursorColor(0xFF00FFFF); inputField.setSurfaceFill(0).setStroke(0xFF00FFFF).setStrokeWeight(thick1).setParent(io);
  inputField.setDragMode(DragMode.NORMAL, DragMode.NONE);
  inputField.setTextPosAndAdjust(inpBuffX,inpBuffY);
  inputField.setCursorThick(thick2);
  
  io.setTyper(inputField);
}

public void initializeKeypad(final float topBuff, final Button palette, final float thick3) {
  //now we do the typing buttons
  //put special sizing variables here, so they can be changed at a whim
  float buttWid=width/6.7f;
  float buttBuff=0.1f*buttWid, rad=buttWid/4;
  float buttHig = (height-inputField.y-inputField.h-2*topBuff-5*buttBuff)/5;
  final float buttBuffX=0.02222f*width, buttBuffY=0.01f*height;
  
  keyPad.setDragMode(DragMode.SWIPE,DragMode.NONE);
  
  final String[][] texts = {{"◄","►","C","/","*","⌫"},{"(",")","7","8","9","-"},{"√","ln","4","5","6","+"},{"π","e E","1","2","3","↩"},{"▼","2nd","0",". i"}};
  
  for(int y=0;y<5;y++) { for(int x=0;x<texts[y].length;x++) {
    float wid = (x==2&&y==4) ? 2*buttWid+buttBuff : buttWid, shift = (x==3&&y==4) ? buttWid+buttBuff : 0, hig = (x==5&&y==3) ? 2*buttHig+buttBuff : buttHig;
    Button butt = new Button(buttBuff+(buttWid+buttBuff)*x+shift,(buttHig+buttBuff)*y,wid,hig,rad).setPalette(palette);
    butt.setParent(keyPad).setText(texts[y][x],0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3);
    if(butt.text[0].text.equals("C")) { butt.setFills(0xFF180000,0xFF300000,0xFF600000).setStrokes(0xFF800000); butt.text[0].fill=0xFFFF0000; }
    else if(butt.text[0].text.equals("↩")) { butt.setFills(0xFF001800,0xFF003000,0xFF006000).setStrokes(0xFF008000); butt.text[0].fill=0xFF00FF00; }
    
    if(y==0) {
      if     (x==0) { butt.setOnRelease(typeAction2(new InputCode(InputCode.LEFT))); }
      else if(x==1) { butt.setOnRelease(typeAction2(new InputCode(InputCode.RIGHT))); }
      else if(x==2) {
        butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
          io.typer.readInput(new InputCode(InputCode.CLEAR)); //clear
          doubleTimes=doubleE=doubleDot=false; //reset test variables
          if(io.typer==inputField) { //if typing in the input field
            clearTimes++;            //increment how many times we pressed clear in a row
            if(clearTimes==10) { //if 10 times:
              clearTimes=0;      //reset to 0
              clearHistory();    //clear history
            }
          }
        } } });
      }
      else if(x==5) { butt.setOnRelease(typeAction2(new InputCode(InputCode.BACKSPACE))); }
      
      else if(x==3) { butt.setOnRelease(typeAnsPrefix('/')); }
      else if(x==4) { butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
        if(io.typer==inputField && io.typer.size()==0) { io.typer.readInput(new int[] {'I',0,'S',4},new String[] {"Ans*"}); }
        else if(doubleTimes) { io.typer.readInput(new int[] {'S',-1,'o',0,'S',1},new char[] {'^'}); }
        else { io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {'*'}); }
        doubleTimes^=true; doubleE = doubleDot = false; clearTimes = 0;
      } } }); }
    }
    else if(y==1 && x==5) { butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
      if(io.typer==inputField && io.typer.size()==1 && io.typer.getText().equals("-")) { io.typer.readInput(new int[] {'S',-1,'I',0,'S',4},new String[] {"Ans"}); }
      else { io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {'-'}); }
      disableTestVars();
    } } }); }
    else if(y==2 && x<2) { butt.setOnRelease(typeAction2(new InputCode(new int[] {'I',0,'S',texts[2][x].length()+1}, new String[] {texts[2][x]+"("}))); }
    else if(y==2 && x==5) { butt.setOnRelease(typeAnsPrefix('+')); }
    else if(y==3 && x==1) { butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
      if(doubleE) { io.typer.readInput(new int[] {'S',-1,'o',0,'S',1}, new char[] {'E'}); }
      else        { io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {'e'}); }
      doubleTimes=false; doubleE^=true; doubleDot=false; clearTimes=0;
    } } }); }
    
    else if(y==3 && x==5) { butt.setOnRelease(new Action() { public void act() { hitEnter(); } }); }
    
    else if(y==4 && x==0) { butt.setOnRelease(new Action() { public void act() { openKeyboard(); } }); }
    else if(y==4 && x==1) { butt.setOnRelease(new Action() { public void act() {
      for(Box b : keyPad) { if(b instanceof Button) {
        String txt = b.text[0].getText();
        if     (txt.equals("/") || txt.equals("(") || txt.equals(")") || txt.equals("√") || txt.equals("ln") || txt.equals(keypadMode.piButton()) || txt.equals("e E") || txt.equals("2nd")) { b.active = false; }
        else if(txt.equals("%") || txt.equals("CTRL+V") || txt.equals("CTRL+A+C") || txt.equals("x²") || txt.equals("^") || txt.equals("Ans") || txt.equals(  ",") || txt.equals("1st")) { b.active =  true; }
      } }
      disableTestVars();
    } }); }
    else if(y==4 && x==3) { butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
      if(doubleDot) { io.typer.readInput(new int[] {'S',-1,'o',0,'S',1}, new char[] {'i'}); }
      else          { io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {'.'}); }
      doubleTimes=doubleE=false; doubleDot^=true; clearTimes=0;
    } } }); }
    else { final char chars = texts[y][x].charAt(0); butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
      io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {chars});
      disableTestVars();
    } } }); }
  } }
  
  //here are some extra buttons that only appear when the 2nd button is pressed
  Button butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*3,0,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("%",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(typeAnsPrefix('%'));
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*0,(buttHig+buttBuff)*1,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("CTRL+V",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) { //TODO remove this once you actually fully implement clipboard accessibility. This will take a lot of time, so no rush...
    String text = getTextFromClipboard();
    if(text!=null) { io.typer.readInput(new int[] {'I',0,'S',text.length()}, new String[] {text}); }
  } } });
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*1,(buttHig+buttBuff)*1,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("CTRL+A+C",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) { //TODO remove this once you actually fully implement clipboard accessibility. This will take a lot of time, so no rush...
    String text = io.typer.getText();
    copyToClipboard(text);
  } } });
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*0,(buttHig+buttBuff)*2,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("x²",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(typeAnsPrefix('²'));
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*1,(buttHig+buttBuff)*2,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("^",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(typeAnsPrefix('^'));
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*0,(buttHig+buttBuff)*3,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("Ans",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(typeAction2(new InputCode(new int[] {'I',0,'S',3}, new String[] {"Ans"})));
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*1,(buttHig+buttBuff)*3,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText(",",0xFF00FFFF,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
    io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {','});
    disableTestVars();
  } } });
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*1,(buttHig+buttBuff)*4,buttWid,buttHig,rad).setPalette(palette).setParent(keyPad).setText("1st",0xFF00FFFF,12,9).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(new Action() { public void act() {
    for(Box b : keyPad) { if(b instanceof Button) {
      String txt = b.text[0].getText();
      if     (txt.equals("/") || txt.equals("(") || txt.equals(")") || txt.equals("√") || txt.equals("ln") || txt.equals(keypadMode.piButton()) || txt.equals("e E") || txt.equals("2nd")) { b.active =  true; }
      else if(txt.equals("%") || txt.equals("CTRL+V") || txt.equals("CTRL+A+C") || txt.equals("x²") || txt.equals("^") || txt.equals("Ans") || txt.equals(  ",") || txt.equals("1st")) { b.active = false; }
    } }
    disableTestVars();
  } });
  butt = (Button)new Button(buttBuff+(buttWid+buttBuff)*0,(buttHig+buttBuff)*3,buttWid,buttHig,rad).setFills(0xFF181800,0xFF303000,0xFF606000).setStrokes(0xFF808000).setParent(keyPad).setText("x π",0xFFFFFF00,buttBuffX,buttBuffY).setStrokeWeight(thick3).setActive(false);
  butt.setOnRelease(new Action() { public void act() { if(io.typer!=null) {
    if(doubleX) { io.typer.readInput(new int[] {'S',-1,'D','i',0,'S',1}, new char[] {'π'}); }
    else        { io.typer.readInput(io.typer.insert ? InputCode.INSERT : InputCode.OVERTYPE, new char[] {'x'}); }
    doubleTimes=doubleE=doubleDot=false; doubleX^=true; clearTimes=0;
  } } });
  
}

public void initializeEquationList(final Button palette, final float addButtHig, final float equationHeight, final float thick2, final float inpBuffY) {
  final float addButtWid = equatHolder.w/4;
  final float colorSelectSize = 0.035555556f*equatHolder.w;
  Button equationAdder = (Button)new Button(0,0,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("Add",0xFF00FFFF);
  Button equationUp = (Button)new Button(addButtWid,0,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("▲",0xFF00FFFF);
  Button equationDown = (Button)new Button(2*addButtWid,0,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("▼",0xFF00FFFF);
  Button equationDelete = (Button)new Button(3*addButtWid,0,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("Delete",0xFF00FFFF);
  
  Button equationCanceler = (Button)new Button(0,equatHolder.h-addButtHig,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("Cancel",0xFF00FFFF); //equationCanceler.disable();
  Button equationVisToggle = (Button)new Button(addButtWid,equatHolder.h-addButtHig,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("Visible?",0xFF00FFFF);
  Button equationMode = (Button)new Button(2*addButtWid,equatHolder.h-addButtHig,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("Mode",0xFF00FFFF);
  equationColor = (Textbox)new Textbox(3*addButtWid,equatHolder.h-addButtHig,addButtWid,addButtHig).setSurfaceFill(0xFF001818).setStroke(0xFF00FFFF).setParent(equatHolder);
  equationColor.setTextSizeAndAdjust(colorSelectSize);
  
  //new Button(equatHolder.w-addButtWid,0,addButtWid,addButtHig).setPalette(palette).setParent(equatHolder).setText("Edit",#00FFFF);
  
  equatList = new Panel(0,addButtHig,equatHolder.w,equatHolder.h-2*addButtHig).setDragMode(DragMode.NONE, DragMode.NORMAL).setScrollableY(true); equatList.setSurfaceFill(0).setStroke(0xFF00FFFF).setParent(equatHolder);
  equatList.setPixPerClick(10);
  
  equationAdder.setOnRelease(new Action() { public void act() { //adds new equation
    float buttY = 0; //first, we have to figure out the y position of the new plottable equation
    if(equatList.children.size()!=0) { buttY = equatList.getChild(equatList.children.size()-1).y+equatList.getChild(equatList.children.size()-1).h; }
    float offset = 0.1f*width, offset2 = 0.0266667f*width, offsetY = 0.0244444f*height;
    
    final Panel pan = (Panel)new Panel(0,buttY,equatList.w,equationHeight).setSurfaceFill(0).setStroke(0xFF00FFFF).setParent(equatList);
    pan.setScrollable(false,false).setDragMode(DragMode.NONE,DragMode.NONE);
    
    final Textbox tbox = new Textbox(offset,0,equatList.w-offset,equationHeight).setCursorColor(0xFF00FFFF).setTextColor(0xFF00FFFF);
    tbox.setSurfaceFill(0).setStroke(false).setParent(pan); tbox.setScrollable(false,false).setDragMode(DragMode.NORMAL,DragMode.NONE);
    tbox.setTextPosAndAdjust(thick2,inpBuffY); tbox.setCursorThick(thick2);
    io.setTyper(tbox); equationCache=tbox;
    tbox.setOnRelease(new Action() { public void act() {
      io.setTyper(tbox); equationCache=tbox; //when we click on an equation textbox, we select it
      updateColorSelector();
    } });
    equatList.setSurfaceH(max(equatList.h, pan.y+pan.h));
    
    pan.setText(new Text("y=",Mmio.xBuff,tbox.ty,tbox.tSize,0xFF00FFFF,LEFT,TOP), new Text(equatList.children.size()+"",Mmio.xBuff+offset2,tbox.ty+offsetY,0.45f*tbox.tSize,0xFF00FFFF,LEFT,TOP));
    
    equatList.chooseTargetRecursive(0.5f*equatList.w,equatList.surfaceH-Mmio.yBuff);
    
    plots.add(new Graphable(0xFFFF8000,new Equation(new ParseList("")))); //add empty graphable
    cancels.add(new String[] {""}); //add empty string
    
    updateColorSelector();
    saveEquations(); //save our current equation list
  } });
  
  equationUp.setOnRelease(new Action() { public void act() { if(equationCache!=null) { //moves current equation up on the list
    int ind;
    for(ind=0;ind<equatList.children.size();ind++) { //first, find the index of the selected typer
      if(equatList.getChild(ind) == equationCache.parent) { break; } //if this is the index of our equation, break so ind stops incrementing
    }
    if(ind==0) { return; } //if the index is 0, quit
    
    Panel first = equationCache.parent, other = (Panel)(equatList.getChild(ind-1)); //grab this equation and the equation before this one
    equatList.swapAAndB(first, other);              //swap their positions in the list
    float y1=other.y; other.y=first.y; first.y=y1;  //swap their geometric positions
    updateSubscripts(); //give them the correct subscripts
    
    Graphable grapher = plots.get(ind); plots.set(ind,plots.get(ind-1)); plots.set(ind-1,grapher);          //swap the graphable equations
    String[] stringer = cancels.get(ind); cancels.set(ind,cancels.get(ind-1)); cancels.set(ind-1,stringer); //swap the stored copies
    
    saveEquations(); //save our current equation list
  } } });
  
  equationDown.setOnRelease(new Action() { public void act() { if(equationCache!=null) { //moves current equation down on the list
    int ind;
    for(ind=0;ind<equatList.children.size();ind++) { //first, find the index of the selected typer
      if(equatList.getChild(ind) == equationCache.parent) { break; } //if this is the index of our equation, break so ind stops incrementing
    }
    if(ind==equatList.children.size()-1) { return; } //if the index is at the end, quit
    
    Panel first = equationCache.parent, other = (Panel)(equatList.getChild(ind+1)); //grab this equation and the equation after this one
    equatList.swapAAndB(first, other);              //swap their positions in the list
    float y1=other.y; other.y=first.y; first.y=y1;  //swap their geometric positions
    updateSubscripts(); //give them the correct subscripts
    
    Graphable grapher = plots.get(ind); plots.set(ind,plots.get(ind+1)); plots.set(ind+1,grapher);          //swap the graphable equations
    String[] stringer = cancels.get(ind); cancels.set(ind,cancels.get(ind+1)); cancels.set(ind+1,stringer); //swap the stored copies
    
    saveEquations(); //save our current equation list
  } } });
  
  equationDelete.setOnRelease(new Action() { public void act() { if(equationCache!=null) { //deletes the current equation from the list
    int ind;
    for(ind=0;ind<equatList.children.size();ind++) { //first, find the index of the selected typer
      if(equatList.getChild(ind) == equationCache.parent) { break; } //if this is the index of our equation, break so ind stops incrementing
    }
    //TODO store a copy of this equation so we can undo a deletion
    
    equatList.children.remove(ind); //remove this from the list
    if(ind<equatList.children.size()) { //perform the rest only if this wasn't the last one
      equatList.getChild(ind).setY(equationCache.parent.y); //move the next equation to our previous position
      for(int n=ind+1;n<equatList.children.size();n++) { //loop through all panels after that one
        equatList.getChild(n).setY(equatList.getChild(n-1).y+equatList.getChild(n-1).h); //set their y position to the previous panel's y position plus its height
      }
    }
    updateSubscripts(); //give them all the correct subscripts
    
    io.setTyper(null); equationCache=null; //deselect any textboxes
    updateColorSelector();
    
    plots.remove(ind);   //remove this equation from the list
    cancels.remove(ind); //remove the stored copy from the list
    
    saveEquations(); //save our current equation list
    
    if(equatList.children.size()==0) { equatList.setSurfaceH(equatList.h); }
    else {
      Box b = equatList.getChild(equatList.children.size()-1);
      equatList.setSurfaceH(max(equatList.h, b.y+b.h));
    }
    equatList.chooseTargetRecursive();
    
    //TODO save a copy of the deleted equation
  } } });
  
  
  
  equationCanceler.setOnRelease(new Action() { public void act() { if(equationCache!=null) {
    int ind;
    for(ind=0;ind<equatList.children.size();ind++) {
      if(equatList.getChild(ind) == equationCache.parent) { break; }
    }
    for(int n=0;n<cancels.get(ind).length;n++) {
      ((Textbox)equationCache.parent.getChild(n)).readInput(new int[] {'C','I',0}, new String[] {cancels.get(ind)[n]});
    }
    io.setTyper(null); equationCache=null; updateColorSelector();
  } } });
  
  equationVisToggle.setOnRelease(new Action() { public void act() { if(equationCache!=null) {
    int ind;
    for(ind=0;ind<equatList.children.size();ind++) {
      if(equatList.getChild(ind) == equationCache.parent) { break; }
    }
    
    if(plots.get(ind).visible ^= true) { //invert visibility. If it is now currently visible:
      equationCache.parent.setSurfaceFill(0);
      equationCache.setSurfaceFill(0);
      equationCache.setTextColor(0xFF00FFFF); equationCache.setCursorColor(0xFFAAAAAA);
      for(Text t : equationCache.parent.text) { t.fill=0xFF00FFFF; }
    }
    else { //otherwise:
      equationCache.parent.setSurfaceFill(0xFF555555);
      equationCache.setSurfaceFill(0xFF555555);
      equationCache.setTextColor(0xFFAAAAAA); equationCache.setCursorColor(0xFFAAAAAA);
      for(Text t : equationCache.parent.text) { t.fill=0xFFAAAAAA; }
    }
    saveEquations(); //save our current equation list
  } } });
  
  equationColor.setOnRelease(new Action() { public void act() { if(equationCache!=null) {
    io.setTyper(equationColor); //set the new typer
  } } });
}

public void updateHistory(Panel history, String quest, String ans) {
  for(int n=0;n<history.children.size()-2;n++) {
    if((n&1)==0) {
      Textbox t1 = (Textbox)history.getChild(n), t2 = (Textbox)history.getChild(n+2);
      String ins = t2.getText();
      t1.readInput(new InputCode(new int[] {'C','I',0}, new String[] {ins}));
    } else {
      history.getChild(n).text[0].text = history.getChild(n+2).text[0].text;
    }
  }
  //history.getChild(history.children.size()-2).text[0].text = quest;
  Textbox tb = (Textbox)history.getChild(history.children.size()-2);
  tb.readInput(new InputCode(new int[] {'C','I',0}, new String[] {quest}));
  history.getChild(history.children.size()-1).text[0].text = ans;
  
  saveHistory();
}



public void clearHistory() {
  for(Box b : historyShow) {
    if(b instanceof Button) { b.text[0].text=""; }
    else if(b instanceof Textbox) { ((Textbox)b).readInput(new InputCode(InputCode.CLEAR), false); }
  }
  saveHistory();
}


public void findAnswer(Panel historyShow) {
  if(io.typer.getText().length()==0) { return; } //empty text: do nothing. I'm serious, do nothing!
  
  ParseList parse = new ParseList(io.typer.getText()); //create parselist from calculator input
  parse.format(); //format the parselist
  
  Equation equat = new Equation(parse); //format to an equation
  equat.squeezeInTimesSigns();          //squeeze in * signs where applicable
  equat.setUnaryOperators();            //convert + and - to unary operators where appropriate
  
  String valid = equat.validStrings();
  if(!valid.equals("valid"))                            { updateHistory(historyShow, io.typer.getText()+"", valid+""); }
  else if(!(valid=equat.  validPars()).equals("valid")) { updateHistory(historyShow, io.typer.getText()+"", valid+""); }
  else if(!(valid=equat.leftHanging()).equals("valid")) { updateHistory(historyShow, io.typer.getText()+"", valid+""); }
  else if(!(valid=equat.countCommas()).equals("valid")) { updateHistory(historyShow, io.typer.getText()+"", valid+""); }
  else {
    equat = equat.shuntingYard(); //convert from infix to postfix
    equat.killCommas();           //remove commas
    equat.parseNumbers();         //parse the numbers
    equat.arrangeRecursiveFunctions(); //implement recursive functions
    
    HashMap<String, MathObj> mapper = new HashMap<String, MathObj>();
    if(historyShow.getChild(historyShow.children.size()-1).text[0].text.equals("")) { mapper.put("Ans",new MathObj(new Complex(Double.NaN))); }
    else                      { mapper.put("Ans",new MathObj(Cpx.complex(historyShow.getChild(historyShow.children.size()-1).text[0].text))); }
    
    MathObj answer = equat.solve(mapper);
    
    //if(answer.isNum() && answer.number.equals(69)) {  } //TODO make this play the sound "nice" as a joke
    
    updateHistory(historyShow, io.typer.getText()+"", answer+"");
    
    io.typer.clear(); io.typer.fixWidth(); io.typer.cursor=0; io.typer.setScrollX(0);
  }
  
  historyShow.chooseTarget(historyShow.w/2,Math.nextDown(historyShow.surfaceH-Mmio.yBuff)); //target to the bottom so we can see the answer (next down is used to avoid roundoff induced targeting errors)
}

public void saveEquation(boolean save) {
  if(equationCache.getText().length()==0) {
    for(int n=0;n<equatList.children.size();n++) { //loop through all equations in the list
      if(equationCache.parent == equatList.getChild(n)) { //once we find it:
        plots.get(n).functions[0] = new Equation(new ParseList("")); //set the plot at that index so that it graphs this empty equation
        cancels.set(n,new String[] {""});                            //set the cancel history at that index so it stores this empty string
        break;                                                       //break out of the loop
      }
    }
    if(save) { io.setTyper(null); equationCache=null; updateColorSelector(); }
  }
  
  else {
    ParseList parse = new ParseList(equationCache.getText()); //create parselist from typed text
    parse.format(); //format the parselist
    
    Equation equat = new Equation(parse); //format to an equation
    equat.squeezeInTimesSigns();          //squeeze in * signs where applicable
    equat.setUnaryOperators();            //convert + and - to unary operators where appropriate
    
    String valid = equat.validStrings();
    if(!valid.equals("valid"))                            { /*display error message*/ }
    else if(!(valid=equat.  validPars()).equals("valid")) { /*display error message*/ }
    else if(!(valid=equat.leftHanging()).equals("valid")) { /*display error message*/ }
    else if(!(valid=equat.countCommas()).equals("valid")) { /*display error message*/ }
    else {
      equat = equat.shuntingYard(); //convert from infix to postfix
      equat.killCommas();           //remove commas
      equat.parseNumbers();         //parse the numbers
      equat.arrangeRecursiveFunctions(); //implement recursive functions
      
      for(int n=0;n<equatList.children.size();n++) { //loop through all equations in the list
        if(equationCache.parent == equatList.getChild(n)) { //once we find it:
          plots.get(n).functions[0] = equat;                     //set the plot at that index so that it graphs this equation
          cancels.set(n,new String[] {equationCache.getText()}); //set the cancel history at that index so it stores this string
          break;                                                 //break out of the loop
        }
      }
      if(save) { io.setTyper(null); equationCache=null; updateColorSelector(); }
    }
  }
  
  if(save) { saveEquations(); }
}

public void saveEquationColor() {
  String text = equationColor.getText();
  String[] rgb = text.split(",");
  
  if(rgb.length==3) {
    boolean worked = true;
    int red=0, green=0, blue=0;
    try { red = Integer.parseInt(rgb[0]); green = Integer.parseInt(rgb[1]); blue = Integer.parseInt(rgb[2]); worked = red==(red&255) && green==(green&255) && blue==(blue&255); }
    catch(Exception ex) { worked = false; }
    
    if(worked) {
      int ind; for(ind=0;ind<equatList.children.size();ind++) {
        if(equatList.getChild(ind) == equationCache.parent) { break; }
      }
      plots.get(ind).stroke = 0xFF000000 | red<<16 | green<<8 | blue;
    }
  }
  
  io.setTyper(equationCache);
  updateColorSelector();
  saveEquations();
}

public void hitEnter() {
  if(io.typer!=null) {
    if(io.typer==inputField) {
      findAnswer(historyShow);
    }
    else if(io.typer.parent!=null && io.typer.parent.parent==equatList) {
      saveEquation(true);
    }
    else if(io.typer==equationColor) {
      saveEquationColor();
    }
    disableTestVars();
  }
}

public void updateSubscripts() { //updates all the subscripts in the equation list
  for(int n=0;n<equatList.children.size();n++) { //loop through all the equations
    for(int k=1;k<equatList.getChild(n).text.length;k+=2) { equatList.getChild(n).text[k].text = n+1+""; } //give them the correct subscripts
  }
}

public void updateColorSelector() {
  if(equationCache==null) {
    equationColor.readInput(InputCode.CLEAR);
    equationColor.setSurfaceFill(0xFF001818);
  }
  
  else {
    int ind; for(ind=0;ind<equatList.children.size();ind++) {
      if(equatList.getChild(ind)==equationCache.parent) { break; }
    }
    int stroke = plots.get(ind).stroke;
    equationColor.setSurfaceFill(stroke);
    int contrast = saturate(~stroke);
    equationColor.setTextColor(contrast);
    equationColor.setCursorColor(contrast);
    String config = ((stroke>>16)&255) + "," + ((stroke>>8)&255) + "," + (stroke&255);
    equationColor.readInput(new int[] {'C','I',0,'S',config.length()}, new String[] {config});
  }
}


public static int saturate(int inp) {
  float red = ((inp>>16)&255)-127.5f, green = ((inp>>8)&255)-127.5f, blue = (inp&255)-127.5f, ratio;
  if(abs(red)>=abs(green) && abs(red)>=abs(blue)) { ratio = 127.5f/abs(red); }
  else if(abs(green)>=abs(red) && abs(green)>=abs(blue)) { ratio = 127.5f/abs(green); }
  else { ratio = 127.5f/abs(blue); }
  
  red*=ratio; green*=ratio; blue*=ratio;
  return 0xFF000000 | round(red+127.5f)<<16 | round(green+127.5f)<<8 | round(blue+127.5f);
}
public static class Mmio extends Panel { //the top level parent of all the IO objects in here, and the class solely responsible for all the IO functionality
  
  /////////////////////////// ATTRIBUTES //////////////////////////////
  
  final PApplet app; //the applet this runs in
  
  Textbox typer = null; //which textbox we're typing into, if any
  
  ArrayList<ArrayList<Buffer>> buffers = new ArrayList<ArrayList<Buffer>>(); //array of arrays of buffers used to buffer items partially off screen
  //each inner array contains buffer objects whose dimensions are powers of 2. Which power? It depends on the index of the outermost array
  long buffTime = System.currentTimeMillis(); //stores the time of the last attempty at buffer garbage collection
  
  ArrayList<Cursor> cursors = new ArrayList<Cursor>(); //all the cursors/touches/mice/pointers on screen
  
  //// specific options and key parameters
  
  int wheelEventX=0, wheelEventY=0; //how many scrolls of the wheel occurred in the last frame, both for horizontal and vertical scrolling
  boolean shiftHeld = false;        //whether shift is being held
  
  
  
  //// default preferences
  static float timing1=0.2f, timing2=0.2f, timing3=0.2f; //the preferred timings for buttons
  static float xBuff=5, yBuff=3; //the expected buffer thickness between the walls and the text inside a textbox
  
  
  
  /////////////////////////// CONSTRUCTORS ///////////////////////////////
  
  Mmio(final PApplet a) {
    app = a; mmio = this;
  }
  
  Mmio(final PApplet a, float x2, float y2, float w2, float h2) {
    super(x2,y2,w2,h2);
    app = a; mmio = this;
  }
  
  ///////////////////////// GETTERS/SETTERS //////////////////////////////
  
  public void setCursorSelect(Cursor curs) { //sets what the cursor is selecting, ASSUMING the cursor was JUST pressed down
    Box box =  this.getCursorSelect(curs); //get the box this cursor is selecting, if any
    curs.setSelect(box);                   //set select to whatever we're pressing
  }
  
  public static void setDefaultButtonTimings(final float a, final float b, final float c) {
    timing1=a; timing2=b; timing3=c;
  }
  
  public static void setDefaultButtonTimings(final float t) { timing1=timing2=timing3 = t; }
  
  public void setTyper(Textbox t) { //sets typer
    typer = t;
  }
  
  
  ///////////////////////// DRAWING/DISPLAY ///////////////////////////////
  
  public void display(PGraphics graph, float buffX, float buffY) {
    if(!active) { return; } //special case: io is inactive, don't display
    
    //first, record all the PGraphics's original drawing parameters
    final boolean fill2 = graph.fill, stroke2 = graph.stroke;
    final int fillColor2 = graph.fillColor, strokeColor2 = graph.strokeColor;
    final float strokeWeight2 = graph.strokeWeight, textSize2 = graph.textSize;
    final int textAlign2 = graph.textAlign, textAlignY2 = graph.textAlignY;
    final int imageMode2 = graph.imageMode;
    
    super.display(graph, buffX, buffY); //next, display
    
    //finally, reset all the PGraphics's original drawing parameters
    graph.fill(fillColor2); if(!fill2) { graph.noFill(); }
    graph.stroke(strokeColor2); graph.strokeWeight(strokeWeight2); if(!stroke2) { graph.noStroke(); }
    graph.textAlign(textAlign2, textAlignY2);
    graph.imageMode(imageMode2);
    if(graph.textSize != textSize2) { graph.textSize(textSize2); }
  }
  
  public void display() { display(app.g,0,0); }
  
  //////////////////////// SELECT PROMOTION //////////////////////
  
  //here, we have a feature I call "select promotion", whereby, if you select a box (with certain exceptions), then move your mouse enough, your select will be
  //"promoted" to the parent panel. If that panel can't be dragged, you go to that panel's parent. So on and so forth until you reach one that drags or you
  //surpass the mmio and reach null.
  
  public static boolean attemptSelectPromotion(Cursor curs) { //looks at a cursor and goes through the process of seeing if it can select promote and then potentially doing it, returning true if it did
    Box select = curs.getSelect(); //get this box's select
    if(select==null || select instanceof Panel && (((Panel)select).dragModeX!=DragMode.NONE || ((Panel)select).dragModeY!=DragMode.NONE)) { return false; } //if null, or if it's a draggable panel, return false
    
    Panel promotion = select.parent; //get select's parent
    while(promotion!=null) {         //loop until the promotion is null
      if(promotion.dragModeX!=DragMode.NONE || promotion.dragModeY!=DragMode.NONE) { break; } //if this panel is draggable, break the loop and set this to our promotion
      else                                                  { promotion = promotion.parent; } //otherwise, promote promotion to its parent and let's try this again
    }
    
    if(promotion!=null && sq(curs.x-curs.xi)+sq(curs.y-curs.yi) >= sq(promotion.promoteDist)) { //If there is a valid promotion, and we moved enough to merit promotion:
      /*if(select instanceof Button) {           //if select is a button:
        ((Button)select).cursors.remove(curs); //remove curs from the list of cursors pressing that button
      }*/
      //TODO remove the above code, it's been replaced by the below code. Do so when you're sure you're ready.
      select.mmio.deselectAllButtons(curs); //force the cursor to deselect all buttons
      
      curs.setSelect(promotion);          //promote the select
      curs.xi = curs.x; curs.yi = curs.y; //update the cursor's initial position
      return true;                        //return true to identify a promotion occurred
    }
    
    return false; //Otherwise, return false
  }
  
  
  //////////////////////// UPDATES ///////////////////////////////
  
  public void updateCursorsAndroid(TouchEvent.Pointer[] touches) {
    int ind = 0; //this represents our index as we iterate through both the touches list & the cursors list
    ArrayList<Cursor> adds = new ArrayList<Cursor>(), //arraylists of the cursors we add,
                      subs = new ArrayList<Cursor>(), //subtract,
                      movs = new ArrayList<Cursor>(); //and move
    
    while(ind<touches.length || ind<cursors.size()) { //loop through both lists until we reach the end of them both
      if(ind==cursors.size() || ind<touches.length && touches[ind].id < cursors.get(ind).id) { //if the touch ID is less than the cursor ID, that means a new touch was added before this cursor. If we're past the end of cursors, a new touch was added at the end
        Cursor curs = new Cursor(touches[ind].x, touches[ind].y).setId(touches[ind].id); //create new cursor to represent that touch
        //curs.press(LEFT);      //make the cursor pressed
        cursors.add(ind,curs); //add it to the list in the correct spot
        adds.add(curs);        //add it to the list of things we added
        ind++;                 //increment the index
      }
      else if(ind==touches.length || ind<cursors.size() && touches[ind].id > cursors.get(ind).id) { //if the touch ID is greater than the cursor ID, or we're past the end of touches, that means this cursor was removed from the touch list.
        subs.add(cursors.get(ind));     //add this cursor to the list of things we removed
        //cursors.get(ind).release(LEFT); //make the cursor released
        cursors.remove(ind);            //remove this cursor from the cursor list
        //don't increment the index, stay in the same place
      }
      else { //same ID:
        if(touches[ind].x != cursors.get(ind).x || touches[ind].y != cursors.get(ind).y) { //first, see if the position has changed
          movs.add(cursors.get(ind));                                 //if so, add this to the list
          cursors.get(ind).updatePos(touches[ind].x, touches[ind].y); //update the position
        }
        ind++; //in any case, increment index, then continue
      }
    }
    
    for(Cursor curs : adds) { //update everything to account for buttons pressed,
      setCursorSelect(curs);
      curs.press(LEFT);
      updateButtons(curs, (byte)1, false);
    }
    for(Cursor curs : subs) { //to account for buttons released,
      curs.release(LEFT);
      updateButtons(curs, (byte)0, false);
      curs.setSelect(null);
    }
    for(Cursor curs : movs) { //and to account for cursors moved
      attemptSelectPromotion(curs);
      updateButtons(curs, (byte)3, false);
    }
  }
  
  public void updatePanelScroll(Cursor curs) {
    if(wheelEventX!=0 || wheelEventY!=0) { updatePanelScroll(curs, wheelEventX, wheelEventY); }
  }
  
  public void updateCursorDPos() { //updates the previous draw cycle positions of each cursor
    for(Cursor curs : cursors) {      //loop through all cursors
      curs.dx=curs.x; curs.dy=curs.y; //set previous positions equal to current positions
    }
  }
  
  
  
  ///////////////////// BUFFERS /////////////////////////////////
  
  public void bufferGarbageCollect() { //performs a garbage collection algorithm on the buffers
    if(System.currentTimeMillis() >= buffTime+1000) { //if it's been at least a second since our last garbage collect:
      for(ArrayList<Buffer> buff : buffers) { //loop through all lists of buffers
        for(int n=0;n<buff.size();n++) {      //loop through said lists
          if(!buff.get(n).wasUsed()) { buff.remove(n); n--; } //if any of the buffers haven't been used in the past 8 seconds, remove them (then decrement so we don't skip)
          else                       { buff.get(n).step();  } //otherwise, make them step in time
        }
      }
      buffTime+=1000; //lastly, increment the buffer time by 1 second so we know to wait another second
    }
  }
  
  public int getBufferNumber() { //gets number of buffers
    int num = 0;
    for(ArrayList<Buffer> buff : buffers) { num+=buff.size(); }
    return num;
  }
  
  public long approxBufferRAM() { //gets approximate RAM used by buffers
    long ram = 0;
    for(int n=0;n<buffers.size();n++) { ram+=buffers.get(n).size() << ((n+1)<<1); } //the RAM of each buffer is approximately 4^(n+1), because it's (2^n)^2 * 4 bytes.
    return ram;
  }
  
  ///////////////////// MISC ///////////////////////////////////
  
  /*
  ArrayList<Box> generateRecursiveList() {
    ArrayList<Panel> list1 = new ArrayList<Panel>(); list1.add(this); //list1 will hold this generation
    ArrayList<Panel> list2;                                           //list2 will hold all the (panel) children of this generation
    ArrayList<Box> list3 = new ArrayList<Box>(); list3.add(this);     //list3 will hold everything
    
    while(!list1.isEmpty()) { //loop until this generation is empty
      
      list2 = new ArrayList<Panel>(); //initialize list2
      for(Panel panel : list1) { //loop through all panels in list1
        for(Box box : panel) {   //loop through all boxes in each panel
          list3.add(box);        //add each box to the total list
          if(box instanceof Panel) { list2.add((Panel)box); } //if it's a panel, add it to list2
        }
      }
      list1 = list2; //set list1 equal to list2
    }
    
    return list3; //return the total list
  }*/
  
  public float getTextWidth(String txt, float siz) { //gets the width of a particular string at a particular size, without changing anything
    Buffer buff = loadBuffer(this, (byte)0); //load a 1x1 PGraphics object
    buff.beginDraw();         //begin draw
    buff.graph.textSize(siz); //set text size
    float wid = buff.graph.textWidth(txt); //get the width
    buff.endDraw();   //end draw
    buff.usent();     //stop using buffer
    return wid;       //return the width
  }
  
  public static float getTextHeight(float siz) { return siz*1.164f+0.902f; } //gets the height of a text of a specific size, assuming there are no "\n"s
  
  public static float invTextHeight(float siz) { return 0.859f*siz-0.775f; } //gets the text size needed for a particular text height
  
  public static float getTextHeight(String txt, float siz) {
    return getTextHeight(siz)*getLines(txt);
  }
  
  public static int getLines(String txt) {
    int lines = 1; for(int n=0;n<txt.length();n++) { if(txt.charAt(n)=='\n') { ++lines; } }
    return lines;
  }
}

/*public static class Pointer {
  public int id;
  public float x, y;
  public float area;
  public float pressure;
}*/
public static  class MathObj { //represents any mathematical object we can plug into our equations
  public Complex number=null; //a number
  public boolean bool=false;  //a boolean
  public String message="";   //a string (usually error message)
  //Matrix matrix; //a matrix
  public VarType type = VarType.NONE; //type of variable
  
  public enum VarType {COMPLEX,BOOLEAN,MATRIX,MESSAGE,NONE}
  
  public MathObj() { type=VarType.NONE; }
  public MathObj(Complex c) { number=c; type=VarType.COMPLEX; }
  public MathObj(boolean b) { bool=b; type=VarType.BOOLEAN; }
  public MathObj(String s) { message=s; type=VarType.MESSAGE; }
  
  public MathObj(Entry e) {
    if(e.getType()==EntryType.NUM) { number = Cpx.complex(e.getId()); type=VarType.COMPLEX; }
    else if(e.getType()==EntryType.CONST) {
      switch(e.getId()) {
        case "e": number = new Complex(Math.E);  type=VarType.COMPLEX; break;
        case "i": number = Cpx.i();              type=VarType.COMPLEX; break;
        case "π": number = new Complex(Math.PI); type=VarType.COMPLEX; break;
        case "γ": number = new Complex(Mafs.GAMMA); type=VarType.COMPLEX; break;
        
        case  "true": bool= true; type=VarType.BOOLEAN; break;
        case "false": bool=false; type=VarType.BOOLEAN; break;
      }
    }
  }
  
  public MathObj(String s, boolean b) {
    if(s.equals("true")) { bool=true; type=VarType.BOOLEAN; }
    else if(s.equals("false")) { bool=false; type=VarType.BOOLEAN; }
    
    else if(s.equals("Overflow")) { number=new Complex(Double.POSITIVE_INFINITY); type=VarType.COMPLEX; }
    else if(s.equals("Negative Overflow")) { number=new Complex(Double.NEGATIVE_INFINITY); type=VarType.COMPLEX; }
    
    else { number=Cpx.complex(s); type = (number==null) ? VarType.NONE : VarType.COMPLEX; }
  }
  
  public boolean isNum() { return type==VarType.COMPLEX; }
  public boolean isBool() { return type==VarType.BOOLEAN; }
  public boolean isMatrix() { return type==VarType.MATRIX; }
  
  public void set(MathObj m) {
    bool=m.bool; number=m.number; message=m.message; /*matrix=m.matrix;*/ type = m.type;
  }
  
  @Override
  public String toString() {
    switch(type) {
      case COMPLEX: return number+"";
      case BOOLEAN: return bool+"";
      case MATRIX: return "";
      case MESSAGE: return message;
      case NONE: return "null";
    }
    return "null";
  }
  
  @Override
  public MathObj clone() {
    switch(type) {
      case COMPLEX: return new MathObj(number.copy());
      case BOOLEAN: return new MathObj(bool);
      case MATRIX: return null;
      case MESSAGE: return new MathObj(message+"");
      case NONE: return null;
    }
    return null;
  }
}
/*
Panels are a bit different than other Boxes. A panel is composed of 3 components: the surface, the window, and the children.
The children are all the components (boxes) which are displayed as part of the panel. The surface acts like a table mat to display all the
children. The window acts as a literal window from which you can view part of the surface. The surface is at least as large as the window, and
can be moved (scrolled) around freely. Meanwhile, only the parts of the surface which are visible through the window are actually displayed.

All the attributes inherited from box apply to the window. fill is false by default, but you can set it to true to cover up the surface. Or, if fillColor is partially transparent, you can use it
to give you a tinted window.

There are also some attributes which were created solely for describing the surface. Namely its position WRT the window, its dimensions, and its background fill
*/

public static class Panel extends Box implements Iterable<Box> {
  
  ////////////////////// ATTRIBUTES ////////////////////////
  
  ArrayList<Box> children = new ArrayList<Box>(); //all the boxes nested in this panel
  
  //surface attributes
  float surfaceX=0, surfaceY=0; //position of surface
  float surfaceW=0, surfaceH=0; //dimensions of surface
  boolean surfaceFill=true;     //whether to fill the surface
  int surfaceFillColor;       //fill color of surface
  
  float surfaceXi=0, surfaceYi=0;       //"initial" position of surface, position when a touch was initialized
  ArrayList<Cursor> pointers = new ArrayList<Cursor>(); //arraylist of all the cursors that are dragging around this surface
  //this is called pointers and not cursors because MMIO already has an arraylist called cursors, and it's used for something else. We don't want that to override this
  
  //targeting attributes:
  SurfaceTarget target = null; //the surface position we target towards (null means we aren't targeting right now)
  
  //// specific options and key parameters
  
  boolean canScrollX = true, canScrollY = true; //whether you can scroll with the mouse
  
  DragMode dragModeX = DragMode.NONE, dragModeY = DragMode.NONE; //the drag mode for this panel, both in the x and y directions. On PC, dragging usually doesn't exist
  float promoteDist = 64; //how many pixels you have to move your cursor from its initial position to trigger select promotion
  
  float pixPerClick; //how many pixels you move per movement of the mouse wheel
  
  ////////////////////// CONSTRUCTORS //////////////////////
  
  Panel() { super(); fill=false; } //by default, you don't fill in the window.
  
  Panel(final float x2, final float y2, final float w2, final float h2, final float w3, final float h3) { super(x2,y2,w2,h2); surfaceX=surfaceY=0; surfaceW=w3; surfaceH=h3; fill=false; initPixPerClick(); } //constructor w/ dimensional parameters
  
  Panel(final float x2, final float y2, final float w2, final float h2) { this(x2,y2,w2,h2,w2,h2); } //constructor w/ fewer dimensional parameters
  
  ////////////////////// GETTERS //////////////////////
  
  public float getSurfaceX() { return surfaceX; } //gets position of surface (in x direction)
  public float getSurfaceY() { return surfaceY; } //gets position of surface (in x direction)
  public float getSurfaceW() { return surfaceW; } //gets width of surface
  public float getSurfaceH() { return surfaceH; } //gets height of surface
  public float getObjSurfaceX() { return getObjX()+surfaceX; } //gets objective position of surface (in x direction)
  public float getObjSurfaceY() { return getObjY()+surfaceY; } //gets objective position of surface (in y direction)
  
  public boolean canScrollX() { return canScrollX; }
  public boolean canScrollY() { return canScrollY; }
  
  public Box getChild(final int ind) { return children.get(ind); }
  
  ////////////////////// MUTATORS //////////////////////
  
  public Panel setSurfaceW(final float w2) { surfaceW=w2; return this; }
  public Panel setSurfaceH(final float h2) { surfaceH=h2; return this; }
  public Panel setSurfaceDims(final float w2, final float h2) { surfaceW=w2; surfaceH=h2; return this; }
  
  public Panel setScrollX(final float x2) { surfaceX=x2; return this; }
  public Panel setScrollY(final float y2) { surfaceY=y2; return this; }
  public Panel setScroll(final float x2, final float y2) { surfaceX=x2; surfaceY=y2; return this; }
  
  public Panel setScrollableX(final boolean s) { canScrollX = s; return this; }
  public Panel setScrollableY(final boolean s) { canScrollY = s; return this; }
  public Panel setScrollable(final boolean sx, final boolean sy) { canScrollX = sx; canScrollY = sy; return this; }
  
  public Panel setSurfaceFill(boolean s) { surfaceFill=s; return this; }
  public Panel setSurfaceFill(int s) { surfaceFillColor=s; return this; }
  
  public void shiftSurface(final float x2, final float y2) {
    surfaceX = constrain(surfaceX+x2, w-surfaceW, 0);
    surfaceY = constrain(surfaceY+y2, h-surfaceH, 0);
  }
  
  public Panel setPixPerClick(final float p) { pixPerClick = p; return this; } //sets the rate of pixels scrolled per click of the mouse (negative means inverted scrolling)
  
  public Panel setDragMode(final DragMode sx, final DragMode sy) { dragModeX = sx; dragModeY = sy; return this; } //sets the dragging mode
  
  ////////////////////// DRAWING/DISPLAY //////////////////////
  
  public void display(PGraphics graph, float buffX, float buffY) {
    
    if(surfaceFill) { graph.fill(surfaceFillColor); } else { graph.noFill(); } //set drawing attributes
    graph.noStroke(); //no stroke, we draw the border afterward
    
    graph.rect(getX()-buffX, getY()-buffY, w, h); //draw the surface background, constrained to within the window
    
    for(Box b : this) { if(b.active) {      //loop through all active children
      displayChild(b, graph, buffX, buffY); //display each child
    } }
    
    extraDisplay(graph, buffX, buffY); //run any extra functionality we might want to run
    
    super.display(graph, buffX, buffY); //finally, draw the window over it all
  }
  
  public void extraDisplay(PGraphics graph, float buffX, float buffY) { } //is used by other, derived classes to draw extra stuff
  
  public void displayChild(Box b, PGraphics graph, float buffX, float buffY) { //displays the child
    
    final byte out = outCode(b.getX(),b.getY(),b.w,b.h,w,h); //use compressed cohen-sutherland algorithm to generate 5-bit outcode
    
    if((out&16)!=16) { //skip all boxes that are completely out of bounds
      if(out==0) { b.display(graph, buffX-getX(), buffY-getY()); } //if box is completely in bounds: display it on the same PGraphics object
      else { //otherwise:
        
        if((out&12)==12) { throw new RuntimeException("ERROR: box is clipped left & right. Such behavior is not yet implemented, try to make children smaller than their parents!"); }
        if((out& 3)== 3) { throw new RuntimeException("ERROR: box is clipped up & down. Such behavior is not yet implemented, try to make children smaller than their parents!"); }
        
        float buffWid = ((out&4)==4 ? w : b.getX()+b.w) - ((out&8)==8 ? 0 : b.getX()), //calculate minimum buffer width
              buffHig = ((out&1)==1 ? h : b.getY()+b.h) - ((out&2)==2 ? 0 : b.getY()); //and minimum buffer height
        //this is done by subtracting the position of the right/bottom minus the position of the left/top.
        
        byte p=0; //the smallest power of 2 whose dimensions can fit this buffered display
        while(buffWid>(1<<p) || buffHig>(1<<p)) { ++p; //continually increment p until we find a power of 2 at least as big as our dimensions
          if(p==32) { throw new RuntimeException("ERROR: buffer dims are "+buffWid+"x"+buffHig+", which exceed the integer maximum. How the fuck did you do this?"); }
        }
        
        Buffer buff = loadBuffer(mmio, p); //Load the smallest buffer of at least size 2^p. If none are available, create your own one and add it to the list
        
        float buffX2 = (out&8)==8 ? 0 : (out&4)==4 ? w-buff. width() : b.getX(), //calc x pos of buffer (WRT panel)
              buffY2 = (out&2)==2 ? 0 : (out&1)==1 ? h-buff.height() : b.getY(); //calc y pos of buffer (WRT panel)
        //left outcode = left of buff on left of panel (0), right outcode = right of buff on right of panel (w-buff.width()), no outcode = left of buff on left of box (b.getX())
        //up and down can be done the same w/out loss of generality
        
        // float x3 = b.getX()+((out&4)==4 ? buffWid-buff. width() : b.w-buffWid), //calc x pos of buffer (WRT panel)
        //       y3 = b.getY()+((out&1)==1 ? buffHig-buff.height() : b.h-buffHig); //calc y pos of buffer (WRT panel)
        // this was the code that was originally used. It was replaced for being too unintuitive and, more importantly, having roundoff,
        // but I still keep it as a comment because there's a certain elegance to it.
        
        buff.beginDraw();                      //put buffer in use & begin drawing
        b.display(buff.graph, buffX2, buffY2); //display button onto buffer (buffX2,buffY2 are the pos of the buffer WRT the panel, which according to Box.display, is what they should be)
        //buff.selfTest();                       // DEBUG test to make sure the buffer's actually there
        buff.endDraw();                        //finish drawing buffer
        
        graph.image(buff.graph, buffX2+getX()-buffX, buffY2+getY()-buffY); //display the buffer in the correct location (buffX2,buffY2 + pos of panel WRT graph)
        
        buff.usent(); //put buffer out of use
      }
    }
  }
  
  public static Buffer loadBuffer(Mmio mmio, byte p) { //Loads smallest available buffer of at least size 2^p x 2^p from mmio. If none are available, it makes one.
    Buffer buff = null; //the buffer we'll be using to draw this crap
    Outer: {            //label the outermost of 2 loops
      for(int ind = p; ind < mmio.buffers.size(); ind++) { //loop through all buffers that are at least big enough to draw this clipped object, find the first one that isn't in use
        for(Buffer buff2 : mmio.buffers.get(ind)) {        //loop through all buffers in each array
          if(!buff2.isInUse()) { buff = buff2; break Outer; } //the first one we find that isn't in use, set that to our buffer, break to the outer loop
        }
      }
    }
    if(buff==null) { //if there were no available buffers:
      mmio.buffers.ensureCapacity(p+1); //first, make sure the buffer array is big enough
      while(mmio.buffers.size()<=p) { mmio.buffers.add(new ArrayList<Buffer>()); }
      //TODO change it so the buffer is always big enough. Do this by manipulating it upon each instantiation and resize (WHAT???)
      
      //buff = new Buffer(mmio.app, 1<<p, 1<<p); //set our buffer to a newly loaded one of adequate size
      buff = new Buffer(mmio.app, 1<<p, min(1<<p, 128));
      mmio.buffers.get(p).add(buff);           //add said buffer to the list
    }
    
    return buff; //return result
  }
  
  ////////////////////// UPDATES ///////////////////////////////
  
  
  public boolean updateButtons(Cursor curs, final byte code, boolean selected) { //looks through all visible buttons in a panel and updates accordingly (selected = whether the cursor has already selected something)
    for(Box b : reverse()) { //loop through all the boxes in the panel (in reverse order)
      if(b instanceof Panel) {                                     //if b is a panel: update it
        selected = ((Panel)b).updateButtons(curs, code, selected); //cast to a panel, update all inner buttons, update selected
      }
      else if(b instanceof Button) {                                   //if b is a button: update it
        selected |= ((Button)b).respondToChange(curs, code, selected); //cast to a button, respond to the change, update selected
      }
    }
    return selected; //return whether something is already selected
  }
  
  //NOTE it is assumed when running this function that the cursor is already inside the panel's parent (or that it has no parent)
  public boolean updatePanelScroll(Cursor curs, int eventX, int eventY) { //PC only (return whether an update actually occurred)
    if(!hitboxNoCheck(curs.x,curs.y)) { return false; } //if mouse is not in hitbox, skip (no check because this test was already performed on the parent)
    
    for(Box b : this) { //loop through all the boxes in the panel
      if(b instanceof Panel) {
        Panel p = (Panel)b; //cast to a panel
        p.updateButtons(curs, curs.press==0 ? (byte)3 : 2, false); //update buttons given the mouse moved (even though it didn't, the panel moved)
        if(p.updatePanelScroll(curs,eventX,eventY)) { return true; } //if an inner panel got an event, return true so we can immediately leave
      }
    }
    
    shiftSurface(canScrollX ? -eventX*pixPerClick : 0,
                 canScrollY ? -eventY*pixPerClick : 0); //move the surface
    
    return canScrollY && eventY!=0 || canScrollX && eventX!=0; //return whether we updated
  }
  
  public void updatePanelDrag() {
    updateDrag(); //update dragging mechanics TODO fix whatever the fuck happens when we drag one panel then drag a panel inside it
    
    for(Box b : this) { //loop through all the boxes in the panel
      if(b instanceof Panel) { ((Panel)b).updatePanelDrag(); } //for each panel, update their panel drags as well
    }
  }
  
  public void deselectAllButtons(Cursor curs) { //removes curs from the cursors list of all buttons in this panel and its children
    for(Box b : this) { //loop through all children
      if(b instanceof Panel) { ((Panel)b).deselectAllButtons(curs); }    //panel: recursively do this on the inner panels
      else if(b instanceof Button) { ((Button)b).cursors.remove(curs); } //button: remove from cursor list
    }
  }
  
  public void targetAllChildren() { //performs moveToTarget on self and all children recursively
    moveToTarget(); //update targeting system
    for(Box b : this) { if(b instanceof Panel) { //loop through all Panel children
      ((Panel)b).targetAllChildren(); //instruct each of them to target themselves and all their children
    } }
  }
  
  ////////////////////// SWIPING FUNCTIONALITY ////////////////////
  
  public void press(final Cursor curs) { //responds to cursor press
    if(!hitbox(curs)) { return; } //if cursor not inside, exit TODO see if this is necessary AND see if you can use hitboxNoCheck
    
    if(pointers.size()==0) { //if this panel has no pointers:
      surfaceXi = surfaceX; surfaceYi = surfaceY; //set our initial surface position
    }
    else { //if this panel DOES have pointers:
      //TODO test this
      float meanX = 0, meanY = 0;         //calculate the difference between the previous mean-of-positions and the current mean-of-positions
      for(Cursor c : pointers) {          //loop through all current pointers
        meanX+=c.x-c.xi; meanY+=c.y-c.yi; //add them together
      }
      meanX-=(curs.x-curs.xi)*pointers.size(); meanY-=(curs.y-curs.yi)*pointers.size(); //this calculation has been optimized so we have to do one fewer division
      float inv = 1/(pointers.size()*(pointers.size()+1)); meanX*=inv; meanY*=inv;      //divide both mean differences by the denominator
      
      surfaceXi+=meanX; surfaceYi+=meanY; //add the adjustment
    }
    pointers.add(curs); //in any case, add this cursor to our list of pointers
  }
  
  public void release(final Cursor curs) { //responds to cursor release
    if(!pointers.contains(curs)) { return; } //if cursor is not in pointer list, exit TODO see if this is even remotely necessary
    
    if(pointers.size()!=1) { //if this isn't the only pointer:
      //TODO test this
      float meanX = 0, meanY = 0;         //calculate the difference between the previous mean-of-positions and the current mean-of-positions
      for(Cursor c : pointers) {          //loop through all current pointers
        meanX+=c.x-c.xi; meanY+=c.y-c.yi; //add them together
      }
      meanX-=(curs.x-curs.xi)*pointers.size(); meanY-=(curs.y-curs.yi)*pointers.size(); //this calculation has been optimized so we have to do one fewer division
      float inv = 1/(pointers.size()*(pointers.size()-1)); meanX*=inv; meanY*=inv;      //divide both mean differences by the denominator
      
      surfaceXi-=meanX; surfaceYi-=meanY; //subtract the adjustment
    } //otherwise, no adjustments are necessary
    
    pointers.remove(curs); //remove this cursor from our list of pointers
  }
  
  public void updateDrag() { //performs updates once per frames based on dragging functionality
    switch(dragModeX) { //what we do depends on the drag mode
      case NONE: break; //none: never do anything
      case NORMAL: if(pointers.size()!=0) { //normal: only do something if there are pointers
        float mean = 0;                              //first, we compute the mean of all the cursors' positions that are pointed at us (minus their initial positions)
        for(Cursor c : pointers) { mean+=c.x-c.xi; } //add them all up
        mean/=pointers.size();                       //divide by how many there are
        surfaceX = constrain(surfaceXi+mean,w-surfaceW,0); //move the surface to its initial position plus that shift
      } break;
      case ANDROID: {
        //TODO this
      } break;
      case IOS: {
        //TODO this
      } break;
      case SWIPE: {
        //TODO this
      } break;
    }
    
    switch(dragModeY) { //what we do depends on the drag mode
      case NONE: break; //none: never do anything
      case NORMAL: if(pointers.size()!=0) { //normal: only do something if there are pointers
        float mean = 0;                              //first, we compute the mean of all the cursors' positions that are pointed at us (minus their initial positions)
        for(Cursor c : pointers) { mean+=c.y-c.yi; } //add them all up
        mean/=pointers.size();                       //divide by how many there are
        surfaceY = constrain(surfaceYi+mean,h-surfaceH,0); //move the surface to its initial position plus that shift
      } break;
      case ANDROID: {
        //TODO this
      } break;
      case IOS: {
        //TODO this
      } break;
      case SWIPE: {
        //TODO this
      } break;
    }
  }
  
  ////////////////////// TARGETING ////////////////////////
  
  public void chooseTarget(float... focus) { //chooses a target, given that all inputted coordinates have to be in focus.
    if((focus.length&1)==1) { throw new IllegalArgumentException("method chooseTarget cannot accept "+focus.length+" inputs (only even numbers are allowed)"); } //if the inputs aren't formatted correctly, throw a runtime exception
    
    float[] focX = new float[focus.length>>1], focY = new float[focus.length>>1]; //arrange our inputs into two arrays (x and y)
    for(int n=0;n<focX.length;n++) { focX[n]=focus[n<<1]; focY[n]=focus[n<<1|1]; } //fill the arrays with our inputs
    
    /*float lowX = w-surfaceW, highX=0, lowY = h-surfaceH, highY=0; //the lower & upper bounds for where we can target
    for(float f : focX) { //loop through all x values
      lowX  = max( lowX,   Mmio.xBuff-f); //lower bound must be the highest of all lower bounds
      highX = min(highX, w-Mmio.xBuff-f); //upper bound must be the lowest of all upper bounds
    }
    for(float f : focY) { //loop through all y values
      lowY  = max( lowY,   Mmio.yBuff-f); //lower bound must be the highest of all lower bounds
      highY = min(highY, h-Mmio.yBuff-f); //upper bound must be the lowest of all upper bounds
    }
    
    if(highX<lowX) { println("fuck", lowX, highX, surfaceX, constrain(surfaceX,lowX,highX)); } //DEBUG
    
    float xTarget = constrain(surfaceX,lowX,highX), yTarget = constrain(surfaceY,lowY,highY); //choose each target to be either the current position or whichever point is just barely in bounds and is closest to the current pos as possible
    */
    
    float[] targetX = new float[2*focX.length+3]; targetX[0]=surfaceX; targetX[1]=w-surfaceW; targetX[2]=0;
    for(int n=0;n<focX.length;n++) {
      targetX[2*n+3]=Mmio.xBuff-focX[n]; targetX[2*n+4]=w-Mmio.xBuff-focX[n];
    }
    float[] targetY = new float[2*focY.length+3]; targetY[0]=surfaceY; targetY[1]=h-surfaceH; targetY[2]=0;
    for(int n=0;n<focY.length;n++) {
      targetY[2*n+3]=Mmio.yBuff-focY[n]; targetY[2*n+4]=h-Mmio.yBuff-focY[n];
    }
    targetX = sort(targetX); targetY = sort(targetY);
    float xTarget = targetX[focX.length+1], yTarget = targetY[focY.length+1];
    
    if(xTarget==surfaceX && yTarget==surfaceY)              { target = null; } //if target is right where we are, target is null (no targeting)
    else { target = new SurfaceTarget(xTarget, yTarget, surfaceX, surfaceY); } //otherwise, set the target
  }
  
  //void chooseTarget(float focX, float focY) { //chooses a target, given that the coordinates (focX,focY) have to be in focus
  //  /*float[] xTargets = {surfaceX, 0, w-surfaceW, Mmio.xBuff-focX, w-Mmio.xBuff-focX}, //choose 5 x targets,
  //          yTargets = {surfaceY, 0, h-surfaceH, Mmio.yBuff-focY, h-Mmio.yBuff-focY}; //and 5 y targets
  //  //there are 5 x targets, one to stay put, one to align the left of the surface w/ the left of the window, one to ditto but with right, one to align the focus with the left of the window, one to ditto on the right
  //  //same goes for y targets, but left & right becomes up & down
    
  //  float bestX = Float.POSITIVE_INFINITY;
  //  for(float x : xTargets) {
  //    if(x<=0 && x>=w-surfaceW && x+focX>=Mmio.xBuff && x+focX<=w-Mmio.xBuff && abs(x-surfaceX)<abs(bestX-surfaceX)) { bestX = x; }
  //    //if(x<=xTargets[1] && x>=xTargets[2] && x>=xTargets[3] && x<=xTargets[4] && abs(x-surfaceX)<abs(bestX-surfaceX)) { bestX = x; }
  //  }
    
  //  float bestY = Float.POSITIVE_INFINITY;
  //  for(float y : yTargets) {
  //    if(y<=0 && y>=h-surfaceH && y+focY>=Mmio.yBuff && y+focY<=h-Mmio.yBuff && abs(y-surfaceY)<abs(bestY-surfaceY)) { bestY = y; }
  //    //if(y<=yTargets[1] && y>=yTargets[2] && y>=yTargets[3] && y<=yTargets[4] && abs(y-surfaceY)<abs(bestY-surfaceY)) { bestY = y; }
  //  }
    
  //  if(bestX==Float.POSITIVE_INFINITY) { throw new RuntimeException("Error: failed to target in the x direction!"+xTargets[0]+","+xTargets[1]+","+xTargets[2]+","+xTargets[3]+","+xTargets[4]); }
  //  if(bestY==Float.POSITIVE_INFINITY) { throw new RuntimeException("Error: failed to target in the y direction!"+yTargets[0]+","+yTargets[1]+","+yTargets[2]+","+yTargets[3]+","+yTargets[4]); }*/
    
  //  float[] xTargets = {w-surfaceW, Mmio.xBuff-focX, surfaceX, w-Mmio.xBuff-focX, 0}, //choose 5 x targets,
  //          yTargets = {h-surfaceH, Mmio.yBuff-focY, surfaceY, h-Mmio.yBuff-focY, 0}; //and 5 y targets
  //  //There are 5 x targets: one to stay put, one to align the left of the surface w/ the left of the window, one to ditto but with right, one to align the focus with the left of the window, one to ditto on the right
  //  //Same goes for y targets, but left & right becomes up & down
    
  //  float bestX = sort(xTargets)[2], bestY = sort(yTargets)[2];
    
  //  if(bestX==surfaceX && bestY==surfaceY) { target = null; } //if our best target is just to stay still, don't create a target
  //  else { target = new SurfaceTarget(bestX, bestY, surfaceX, surfaceY); } //otherwise, do
  //}
  
  public void chooseTargetRecursive(float... focus) { //recursively chooses a target, both for this panel and its parent panels
    chooseTarget(focus);     //choose a target for this panel
    
    if(parent!=null && mobile) { //and, if we have a parent (and are mobile)
      PVector targ = (target==null) ? new PVector(surfaceX,surfaceY) : new PVector(target.x,target.y); //record the target, accounting for the possibility that there was no target
      
      float focus2[] = new float[focus.length];
      for(int n=0;n<focus.length;n++) { focus2[n]=focus[n] + ((n&1)==0 ? x+targ.x : y+targ.y); }
      parent.chooseTargetRecursive(focus2);
    }
  }
  
  public void moveToTarget() { //moves towards and updates target
    if(target==null) { return; } //if there is no target, skip
    
    long time = System.currentTimeMillis(); //calculate current time
    float progress = (time-target.time)/PApplet.parseFloat(SurfaceTarget.duration); //calculate targeting progress
    
    if(progress>=1) { //if the target time is worn up:
      setScroll(target.x,target.y); //move to the target
      target = null;                //remove the target
    }
    else { setScroll(lerp(target.xi,target.x,progress), lerp(target.yi,target.y,progress)); } //otherwise, calculate current position w/ a lerp
  }
  
  ////////////////////// CHILDREN /////////////////////////
  
  public void putInBack(Box a) { //puts box in the back
    if(this==a.parent) { children.remove(a); children.add(0,a); } //if this is a's parent, remove a and put it in the back
  }
  
  public void putInFront(Box a) { //puts box in the front
    if(this==a.parent) { children.remove(a); children.add(a); } //if this is a's parent, remove a and put it in the front
  }
  
  public void putAOverB(Box a, Box b) { //puts the first in front of the second
    if(this!=a.parent || this!=b.parent || a==b) { return; }    //only works if they're both distinct children
    int indA = children.indexOf(a), indB = children.indexOf(b); //get indices of a and b
    if(indA < indB) { //if a was already in front of b, do nothing. Otherwise:
      children.remove(indA); children.add(indB,a); //remove a, then put it back in front of b (right where b was before)
    }
  }
  
  public void putABehindB(Box a, Box b) { //puts the first behind the second
    if(this!=a.parent || this!=b.parent || a==b) { return; }    //only works if they're both distinct children
    int indA = children.indexOf(a), indB = children.indexOf(b); //get indices of a and b
    if(indA > indB) { //if a was already behind b, do nothing. Otherwise:
      children.remove(indA); children.add(indB,a); //remove a, then put it back behind b (right where b is now)
    }
  }
  
  public void swapAAndB(Box a, Box b) { //swaps both boxes in positions
    if(this!=a.parent || this!=b.parent || a==b) { return; }    //only works if they're both distinct children
    int indA = children.indexOf(a), indB = children.indexOf(b); //get indices of a and b
    children.set(indA,b); children.set(indB,a);                 //move a into b and b into a
  }
  
  ////////////////////// OTHER //////////////////////
  
  //NOTE: only use if cursor is in the parent's hitbox, or if there is no parent
  protected Box getCursorSelect(Cursor curs) { //searches through a panel and returns which object this cursor is hovering over
    if(!hitboxNoCheck(curs)) { return null; }  //if cursor is not in hitbox, skip
    
    for(Box b : reverse()) {   //loop through all the boxes in the panel
      if(b instanceof Panel) { //if b is a panel:
        Box b2 = ((Panel)b).getCursorSelect(curs); //perform this recursively on said panel
        if(b2!=null) { return b2; }                //if b2 isn't null, return it TODO make sure this works with overlapping boxes. I'm pretty sure it does
      }
      else if(b.hitboxNoCheck(curs)) { return b; } //if b isn't a panel, return b iff the cursor is in it's hitbox (nocheck = don't check parent's hitbox, it's redundant)
    }
    
    return this; //if we're in it's hitbox, but not the hitboxes of any of its children, return this panel
  }
  
  public Iterator<Box> iterator() { //to iterate across the panel, just iterate across its children
    return children.iterator();
  }
  
  public Iterable<Box> reverse() { return new Iterable<Box>() { //returns something you can use to iterate over the children in reverse order
    public Iterator<Box> iterator() { return new Iterator<Box>() { //the iterator returns an iterator
      int index = children.size();                  //initial index is right after the last index
      public boolean hasNext() { return index!=0; } //has next: true if index isn't 0
      public Box next() { index--; return children.get(index); } //next: decrement index and return box at this spot
    }; }
  }; }
  
  public void initPixPerClick() { pixPerClick = (surfaceH-h)*0.05f; } //generally, we can init scroll rate as a fraction of the surface height
}

static class SurfaceTarget { //a class dedicated to the targeting system for targets, implemented to prevent panels from going out of bounds when they change in size and to force us to see important things
  float x, y;   //x and y coordinate of the surface once it reaches its target
  float xi, yi; //x and y coordinates initially, before we started targeting
  long time;    //the UNIX time in ms when the targeting first began. This is here because targeting isn't a sudden jolt, it has to occur over several frames
  static int duration = 120; //the time in ms for the surface to reach its target (same for all targets)
  
  SurfaceTarget(float x2, float y2, float x3, float y3, long time2) { x=x2; y=y2; xi=x3; yi=y3; time=time2; } //constructor w/ all attributes
  
  SurfaceTarget(float x2, float y2, float x3, float y3) { x=x2; y=y2; xi=x3; yi=y3; time=System.currentTimeMillis(); } //constructor w/ xs & ys, and w/ time set to current time
}

public static byte outCode(float xin, float yin, float win, float hin, float wout, float hout) { //yields a 5-bit outcode describing how two boxes intersect, assuming (xout,yout)=(0,0)
  return (byte)((xin>wout || yin>hout || xin+win<0 || yin+hin<0 ? 16 : 0) | //bit 1: whether box is completely out of bounds
                                                      (xin<   0 ?  8 : 0) | //bit 2: whether left edge is left of clipping plane
                                                      (xin+win>wout ?  4 : 0) | //bit 3: whether right edge is right of clipping plane
                                                      (yin<   0 ?  2 : 0) | //bit 4: whether top edge is above clipping plane
                                                      (yin+hin>hout ?  1 : 0)); //bit 5: whether bottom edge is below clipping plane
}

static enum DragMode { NONE, NORMAL, ANDROID, IOS, SWIPE };
//the modes that you can use to drag with your cursor: no dragging, normal (no momentum), android style, iOS style, and swipe between screens (like on a home screen)

///movement modes: PC, Android, iOS, basicSmartphone
public static class ParseList implements Iterable<String> { //a class specifically for taking a list of chars, reorganizing them for parsing reasons, then being converted to an equation
  public ArrayList<String> list = new ArrayList<String>(); //storage of all the strings that'll be parsed into an expression
  
  public ParseList(String inp) { //splits up all the chars and creates a new ParseList
    char[] arr = inp.toCharArray();       //split string into char array
    list.add("(");                        //add a left parenthesis at the beginning
    for(char c : arr) { list.add(c+""); } //cast each char to a string and add to list
    list.add(")");                        //add a right parenthesis at the end
  }
  
  @Override
  public Iterator<String> iterator() {
    return list.iterator();
  }
  
  public int size() { return list.size(); }
  
  public void concat(int ind, String str) {
    list.set(ind,list.get(ind)+str);
  }
  
  @Override
  public String toString() {
    String ret = "";
    for(String s : this) { ret+=s+", "; }
    return ret;
  }
  
  public void groupFuncs() { //group together functions
    ArrayList<Integer> parPos = leftParPosList(); //get a list of the positions of all left parentheses
    
    for(String match : Equation.funcList) { //loop through all strings in the list of function names (big to small)
      for(int k=0;k<parPos.size();k++) {    //loop through all left parentheses
        int pos = parPos.get(k);            //record the position in the list
        
        int startPos = pos-match.length()+1; //find the position of the start of the match
        if(startPos>=0) {                    //first make sure it's non-negative
          boolean matches = matchFound(startPos, match); //see if this string is right before this parenthesis
          
          if(matches) { //if it WAS a match
            groupStringOfSize(startPos,match.length()); //group together strings over that range into one string
            
            parPos.remove(k); //remove this parenthesis position
            for(int n=k;n<parPos.size();n++) {
              parPos.set(n,parPos.get(n)-match.length()+1); //shift each position to the right of this left by pos
            }
            k--; //go back 1 step
          }
        }
      }
    }
  }
  
  public void groupVars() { //group together variable names that are multiple characters long
    for(String match : Equation.varList) { //loop through all strings in the list of variable names (big to small)
      for(int k=0;k<=size()-match.length();k++) { //loop through all the strings (exclude parts at the end where this string doesn't fit)
        boolean matches = matchFound(k, match); //see if this string is a match
        
        if(matches) { //if it WAS a match
          groupStringOfSize(k,match.length()); //group together strings over that range into one string
        }
      }
    }
  }
  
  public boolean matchFound(int pos, String match) { //match found for match at pos
    boolean matches = true;             //whether or not this is a match (default to true)
    for(int n=0;n<match.length();n++) { //loop through all strings between
      if(!(match.charAt(n)+"").equals(list.get(n+pos))) { matches=false; break; } //if any of them don't match, matches is false, leave
    }
    return matches; //return whether they match
  }
  
  public void groupStringOfSize(int pos, int siz) { //take a group of siz strings at position pos and group them together
    for(int n=1;n<siz;n++) {         //loop through all strings in that set
      concat(pos,list.get(pos+1)); //concat them onto the first string on the set
      list.remove(pos+1);          //remove each element after they're concatted
    }
  }
  
  public ArrayList<Integer> leftParPosList() { //get a list of the positions of all left parentheses
    ArrayList<Integer> parPos = new ArrayList<Integer>(); //arraylist of the positions of each left parenthesis
    for(int n=0;n<size();n++) {
      if(list.get(n).equals("(")) { parPos.add(n); } //add each index containing a left parenthesis
    }
    return parPos; //return result
  }
  
  public void groupNums() { //group together numeric values
    boolean numb = false; //whether we're building a number
    boolean deci = false; //whether our number has a decimal point (yet)
    boolean expon = false; //whether our number has an exponential E (yet)
    
    for(int n=0;n<list.size();n++) {    //loop through all strings in the list
      if(list.get(n).length()==1) {   //if this string is 1 character long:
        char c = list.get(n).charAt(0); //cast to a char
        if (c >= '0' && c <= '9' || c == '.' || c == 'E') { //if the string is a numeral, decimal pont, or E
          if (numb && !(c == '.' && (deci || expon) || c == 'E' && expon)) { //case 1: we were already combining tokens into a number (and this makes a valid addition to said #)
            concat(n-1,c+"");                      //add this character to the number
            list.remove(n); --n;                   //remove this entry from the list, then go backwards 1
          }
          else {                    //case 2: we need to form a new number from these digits
            numb = true;          //we're now building a number
            deci = expon = false; //both deci & expon are initially false
            if (c == '.' || c == 'E') {
              list.set(n, '0' + list.get(n));
            } //if it's a . or E, put a 0 before it to properly start the number
          }
          //(programmer's note: if someone creates a number with 2 decimal points or E's or whatever, it'll be interpreted as 2 numbers adjacent to each other)
          
          deci  |= c == '.'; //deci is true if we've had at least one decimal point
          expon |= c == 'E';
        } else if ((c == '+' || c == '-') && numb && list.get(n-1).endsWith("E")) { //if this is a + or -, and the previous character was E:
          concat(n-1,c+"0");   //concatenate this symbol onto the number, followed by a 0 in case we stop at this point
          list.remove(n); --n; //remove this entry from the list & go backwards 1
        }
        else {                  //otherwise:
          if(numb && list.get(n-1).endsWith("E")) { //if the previous thing ended with E,
            concat(n-1,"0");                    //concatenate a 0 at the end to make it valid
          }
          numb = false;                           //we're no longer editing numbers
        }
      }
      else if(numb) { //if it's not 1 character long, but we were in number building mode
        if(list.get(n-1).endsWith("E")) { concat(n-1,"0"); } //if it ended with E, put a 0 at the end to make it valid
        numb = false;                                        //we're no longer in number building mode
      }
    }
  }
  
  public void groupPlusMinus() { //group together adjacent plus and minuses
    boolean plusMinus = false; //whether we're grouping them together now
    for(int n=0;n<size();n++) { //loop through all items
      if(list.get(n).equals("+") || list.get(n).equals("-")) { //if this item is + or -
        if(plusMinus) {     //if the previous was +/-
          list.set(n-1, (list.get(n-1).equals("+") ^ list.get(n).equals("+")) ? "-" : "+"); //set the previous to either + or -
          list.remove(n); //remove this entry
          n--;            //go backwards 1
        }
        plusMinus = true; //set plusMinus to true
      }
      else { plusMinus = false; } //otherwise, set plusMinus
    }
  }
  
  public void groupOps() { //group together operators when applicable (**=^, //=truncated division)
    boolean times=false, div=false, and=false, or=false, greater=false, less=false, not=false, equals=false; //whether we're grouping *, /, &, |, >, <, !, =
    for(int n=0;n<size();n++) { //loop through all items
      if(list.get(n).equals("*")) { //if this item is *
        if(times) { //if the previous was also *
          list.set(n-1, "^"); //set the previous to a ^
          list.remove(n);     //remove this entry
          n--;                //go backwards 1
        }
        times^=true; //invert times
      }
      else { times=false; } //otherwise, set times to false
      
      if(list.get(n).equals("/")) { //if this item is /
        if(div) { //if the previous was also /
          list.set(n-1, "//"); //set the previous to a //
          list.remove(n);      //remove this entry
          n--;                 //go backwards 1
        }
        div^=true; //invert div
      }
      else { div=false; } //otherwise, set div to false
      
      if(list.get(n).equals("&")) { //if this item is &
        if(and) { //if the previous was also &
          list.set(n-1, "&&"); //set the previous to an &&
          list.remove(n);      //remove this entry
          n--;                 //go backwards 1
        }
        and^=true; //invert and
      }
      else { and=false; } //otherwise, set and to false
      
      if(list.get(n).equals("|")) { //if this item is |
        if(or) { //if the previous was also |
          list.set(n-1, "||"); //set the previous to an ||
          list.remove(n);      //remove this entry
          n--;                 //go backwards 1
        }
        or^=true; //invert and
      }
      else { or=false; } //otherwise, set or to false
      
      if(list.get(n).equals("=")) { //if this item is =
        if(greater) { //if the previous was >:
          list.set(n-1, ">="); //set the previous to >=
          list.remove(n);      //remove this entry
          n--;                 //go backwards 1
        }
        else if(less) { //if the previous was <:
          list.set(n-1, "<="); //set the previous to <=
          list.remove(n);      //remove this entry
          n--;                 //go backwards 1
        }
        else if(not) { //if the previous was !:
          list.set(n-1, "!="); //set the previous to !=
          list.remove(n);      //remove this entry
          n--;                 //go backwards 1
        }
        else if(equals) { //if the previous was =:
          list.set(n-1,"=="); //set the previous to ==
          list.remove(n);     //remove this entry
          n--;                //go backwards 1
        }
        equals^=true;
      }
      else { equals=false; } //otherwise, set equals to false
      
      greater = list.get(n).equals(">"); //set greater to true iff this is >
      less    = list.get(n).equals("<"); //set less to true iff this is <
      not     = list.get(n).equals("!"); //set not to true iff this is !
    }
  }
  
  public void format() { //formats the parselist appropriately
    groupFuncs();     //group together functions
    groupVars();      //group together multi-character variables
    groupNums();      //group together numerals
    groupOps ();      //group together combinable operators
    groupPlusMinus(); //clump together plus and minuses
  }
}







public void saveHistory() {
  PrintWriter writer = createWriter("History.txt");
  for(Box b : historyShow) {
    if(b instanceof Textbox) { writer.println(((Textbox)b).getText()); }
    else { writer.println(b.text[0]); }
  }
  writer.flush(); writer.close();
}

public void saveEquations() {
  PrintWriter writer = createWriter("Equations.txt");
  writer.println(plots.size());
  for(int n=0;n<plots.size();n++) {
    writer.println(hex(plots.get(n).stroke));
    writer.println(plots.get(n).visible);
    writer.println(plots.get(n).mode);
    for(int k=0;k<cancels.get(n).length;k++) {
      writer.println(cancels.get(n)[k]);
    }
  }
  writer.flush(); writer.close();
}

public void loadHistory() {
  BufferedReader reader = createReader("History.txt");
  for(Box b : historyShow) {
    String line;
    try { line = reader.readLine(); }
    catch(IOException ex) { line = null; ex.printStackTrace(); }
    
    if(b instanceof Textbox) { ((Textbox)b).readInput(new int[] {'C','I',0}, new String[] {line}); }
    else { b.text[0].text = line; }
  }
  try { reader.close(); }
  catch(IOException ex) { ex.printStackTrace(); }
}

public void loadEquations() {
  BufferedReader reader = createReader("Equations.txt");
  int size;
  try { size = PApplet.parseInt(reader.readLine()); }
  catch(IOException ex) { ex.printStackTrace(); return; }
  
  for(int n=0;n<size;n++) {
    String line1, line2, line3;
    try { line1=reader.readLine(); line2=reader.readLine(); line3=reader.readLine(); }
    catch(IOException ex) { line1=line2=line3=null; ex.printStackTrace(); }
    
    int stroke = unhex(line1); boolean vis = line2.equals("true"); GraphMode mode = GraphMode.valueOf(line3); //grab the first 3 attributes: stroke color, visibility, and graphing mode
    String[] texts = new String[mode.outs()];
    
    float buttY = 0; //first, we have to figure out the y position of the new plottable equation
    if(equatList.children.size()!=0) { buttY = equatList.getChild(equatList.children.size()-1).y+equatList.getChild(equatList.children.size()-1).h; }
    final float equationHeight=0.05555556f*height;
    float offset = 0.1f*width, offset2 = 0.0266667f*width, offsetY = 0.0244444f*height;
    float inpBuffY=0.007778f*height, thick2=0.002222f*width;
    
    Panel pan = (Panel)new Panel(0,buttY,equatList.w,equationHeight).setSurfaceFill(0).setStroke(0xFF00FFFF).setParent(equatList); //load the panel
    pan.setScrollable(false,false).setDragMode(DragMode.NONE,DragMode.NONE);
    
    /*for(int k=0;k<mode.outs();k++) {
      String line;
      //add each textbox
    }*/ //TODO make this compatible with multiple outputs
    
    String line;
    try { line=reader.readLine(); }
    catch(IOException ex) { line=null; ex.printStackTrace(); }
    
    
    final Textbox tbox = new Textbox(offset,0,equatList.w-offset,equationHeight).setCursorColor(0xFF00FFFF).setTextColor(0xFF00FFFF);
    tbox.setSurfaceFill(0).setStroke(false).setParent(pan); tbox.setScrollable(false,false).setDragMode(DragMode.NORMAL,DragMode.NONE);
    tbox.setTextPosAndAdjust(thick2,inpBuffY); tbox.setCursorThick(thick2);
    tbox.setOnRelease(new Action() { public void act() {
      io.setTyper(tbox); equationCache=tbox; //when we click on an equation textbox, we select it
      updateColorSelector();
    } });
    tbox.readInput(new int[] {'C','I',0}, new String[] {line});
    
    pan.setText(new Text("y=",Mmio.xBuff,tbox.ty,tbox.tSize,0xFF00FFFF,LEFT,TOP), new Text(equatList.children.size()+"",Mmio.xBuff+offset2,tbox.ty+offsetY,0.45f*tbox.tSize,0xFF00FFFF,LEFT,TOP));
    
    equatList.chooseTargetRecursive(0.5f*equatList.w,equatList.surfaceH-Mmio.yBuff);
    
    Graphable gr = new Graphable(stroke,new Equation(new ParseList(""))); gr.setVisible(vis);
    plots.add(gr);                    //add graphable
    cancels.add(new String[] {line}); //add equation
    
    if(!vis) {
      pan.setSurfaceFill(0xFF555555);
      tbox.setSurfaceFill(0xFF555555);
      tbox.setTextColor(0xFFAAAAAA); tbox.setCursorColor(0xFFAAAAAA);
      for(Text t : pan.text) { t.fill=0xFFAAAAAA; }
    }
    
    equationCache = tbox;
    saveEquation(false);
  }
  try { reader.close(); }
  catch(IOException ex) { ex.printStackTrace(); }
  
  if(equatList.children.size()!=0) {
    equatList.setSurfaceH(max(equatList.h, equatList.getChild(equatList.children.size()-1).y+equatList.getChild(equatList.children.size()-1).h));
  }
  
  equationCache = null;
}




///////////////////////////////////////// CLIPBOARD STUFF ///////////////////////////////////

//This next set of code is dumped from:
//https://forum.processing.org/two/discussion/8950/pasted-image-from-clipboard-is-black
//https://forum.processing.org/two/discussion/17270/why-this-getx-method-is-missing-in-processing-3-1-1

/*Object getFromClipboard(DataFlavor flavor) { //extracts all items of flavor "flavor" from the clipboard, and returns them as an abstract object
  Clipboard clipboard=Toolkit.getDefaultToolkit().getSystemClipboard(); //create an instance of the "Clipboard" class with the contents of the clipboard
  Transferable contents=clipboard.getContents(null);                    //get them onto a "Transferable" object
  Object object=null;                                                   //create an object to dump the contents onto
  
  if(contents!=null && contents.isDataFlavorSupported(flavor)) { //if the contents aren't null, and this data flavor is supported:
    try { object = contents.getTransferData(flavor); } //try getting transferable data
    catch(UnsupportedFlavorException e1) { }           //requested data flavor not supported (unlikely but still possible)
    catch(java.io.IOException e2) { }                  //data no longer available in the requested flavor
  }
  return object; //return the object
}*/

/*String getTextFromClipboard(){ //this extracts string data from the clipboard (if applicable)
  String text=(String)getFromClipboard(DataFlavor.stringFlavor); //get string flavored data and cast to a string
  return text;                                                   //return the text
}*/

//And this set is dumped from:
//https://stackoverflow.com/questions/11596368/set-clipboard-contents

/*void copyToClipboard(String text) {
  StringSelection selection = new StringSelection(text);
  Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
  clipboard.setContents(selection, selection);
}*/

//The following code is dumped from:
//https://discourse.processing.org/t/i-need-to-find-these-libraries/20484
//Credit to user @noel




static Activity activity;
static Context context;
static ClipboardManager clipboard;

public static void androidInitClipboard(final PApplet app) {
  activity = app.getActivity();
  context = activity.getApplicationContext();
  Looper.prepare();
  clipboard = (ClipboardManager)context.getSystemService(Context.CLIPBOARD_SERVICE);
}

public String getTextFromClipboard(){ //this extracts string data from the clipboard (if applicable)
  ClipData clip = clipboard.getPrimaryClip(); //load the primary clip
  if(clip==null) { return null; }             //if null, return null
  CharSequence cs = clip.getItemAt(0).getText(); //grab the text from the clipboard
  return String.valueOf(cs);                  //cast to a string and return result
}

public void copyToClipboard(String text) {
  ClipData clip = ClipData.newPlainText("text", text); //cast string of text into clipdata object
  clipboard.setPrimaryClip(clip);                      //set that as our primary clipboard data
}





/*String printSupportedDataFlavors() {
  DataFlavor[] avail=Toolkit.getDefaultToolkit().getSystemClipboard().getAvailableDataFlavors();
  StringList formats=new StringList();
  for(DataFlavor f : avail) {
    String edit=f+"";
    edit=edit.substring(edit.indexOf(";")+1);
    edit=edit.substring(0,edit.length()-1);
    if(edit.indexOf(";")!=-1) { edit=edit.substring(0,edit.indexOf(";")); }
    edit=edit.substring("representationclass=".length());
    while(edit.indexOf(".")!=-1) { edit=edit.substring(edit.indexOf(".")+1); }
    
    boolean add = true;
    for(String s : formats) {
      if(edit.equals(s)) { add=false; break; }
    }
    if(add) { formats.append(edit); }
  }
  
  String ret="";
  for(String s : formats) {
    if(!s.equals(formats.get(0))) { ret+=", "; }
    ret+=s;
  }
  return ret;
}*/
public static class Textbox extends Panel {
  
  ////////////////////// ATTRIBUTES /////////////////////////
  
  //text
  float tx, ty; //x & y of text's top left WRT surface
  float tSize; int tFill; //text size & color
  ArrayList<SimpleText> texts = new ArrayList<SimpleText>(); //the texts themselves
  CursorMover buddy; //invisible box to allow for mouse-based/touch-based text cursor placement
  Action releaseAction = emptyAction; //the action that gets performed when you press the buddy, along with 
  
  //cursor
  int cursor = 0; //the position of the blinking cursor
  int cStroke;  //the color of the blinking cursor
  float cThick = 1; //the stroke weight of the cursor
  long blink; //the time when the blinking cursor was last reset
  boolean insert=true; //true=insert, false=overtype. Inverts every time we hit the "insert" key
  
  ///////////////////// CONSTRUCTORS ///////////////////////
  
  Textbox(final float x2, final float y2, final float w2, final float h2) {
    super(x2,y2,w2,h2); //just run the inherited method
    
    tx=Mmio.xBuff; ty=Mmio.yBuff; //then initialize some stuff to their default values
    tSize = (h2-2*Mmio.yBuff-0.902f)/1.164f; //choose a text size with the appropriate height
    
    buddy = new CursorMover(this); //initialize our cursor buddy
  }
  
  ////////////////// GETTERS / SETTERS //////////////////////
  
  public float getTextHeight() { return tSize*1.164f+0.902f; }
  
  public Textbox setTextX(float x2) { tx=x2; fixWidth(); return this; }
  public Textbox setTextY(float y2) { ty=y2; return this; }
  public Textbox setTextPos(float x2, float y2) { tx=x2; ty=y2; fixWidth(); return this; }
  public Textbox setTextYAndAdjust(float y2) { ty=y2; tSize=Mmio.invTextHeight(h-2*ty); fixWidth(); return this; }
  public Textbox setTextPosAndAdjust(float x2, float y2) { tx=x2; ty=y2; tSize=Mmio.invTextHeight(h-2*ty); fixWidth(); return this; }
  
  public Textbox setTextColor  (int   c) { tFill=c; return this; }
  public Textbox setCursorColor(int   c) { cStroke=c; return this; }
  public Textbox setCursorThick(float wgt) { cThick=wgt; return this; }
  public Textbox setTextSize   (float siz) { tSize=siz; return this; }
  public Textbox setTextSizeAndAdjust(float siz) { tSize=siz; ty=0.5f*(h-Mmio.getTextHeight(siz)); return this; }
  
  @Override public 
  Textbox setW(final float w2) { super.setW(w2); buddy.setW(w2); return this; } //when resizing width, the buddy must be resized as well
  
  @Override public 
  Textbox setParent(final Panel p) { super.setParent(p); buddy.mmio=mmio; return this; } //set parent is done differently here because we also have to give our buddy the same mmio as ourselves
  
  public Textbox setOnRelease(final Action act) { releaseAction = act; return this; } //sets the release action
  
  ////////////////// DISPLAY //////////////////////
  
  @Override public 
  void extraDisplay(PGraphics graph, float buffX, float buffY) { //displays the text in the textbox
    graph.fill(tFill); graph.textSize(tSize); graph.textAlign(LEFT,TOP); //set proper drawing parameters
    float yTop = ty+getY()+surfaceY-buffY; //y coord of top of text
    
    if(surfaceX==0 && w==surfaceW) { //if all the text fits on screen:
      for(SimpleText txt : texts) { //loop through all chars in the text
        graph.text(txt+"",txt.x+getX()+surfaceX-buffX,yTop); //display them TODO make sure this actually fucking works, delete me when you're done
      }
    }
    else { //otherwise, use a binary search to find them
      /*int left=0, right=size(); int middle = (left+right)>>1;
      while(true) {
        if(getX(middle)+surfaceX-tx>w) { right = middle-1; }
        else if(getX(middle)+surfaceX-tx<0) { left = middle+1; }
        else { break; }
        middle = (left+right)>>1;
      }
      //and now, left is left of the textbox, right is right of the textbox, and middle is inside the textbox
      int right2=right, left2=middle; //store the right and middle for when we calculate the right bound later
      
      //now, let's calculate the left bound
      right = middle; middle = (left+right)>>1; //shift
      while(left<=right && getX(middle)+surfaceX-tx!=0) { //loop until the bounds are reversed (or until we reach an exact match)
        if(getX(middle)+surfaceX-tx>0) { right = middle-1; } //too far right: make middle the right bound
        else { left = middle+1; }                                 //too far left: make middle the left bound
        middle = (left+right)>>1;                                 //set new middle
      }
      left = middle;
      
      //now, let's calculate the right bound
      middle = (left2+right2)>>1; //center
      while(left2<=right2 && getX(middle)+surfaceX-tx>0) { //loop until the bounds are reversed (or until we reach an exact match)
        if(getX(middle)+surfaceX-tx>0) { right2 = middle-1; } //too far right: make middle the right bound
        else { left2 = middle+1; }                                 //too far left: make middle the left bound
        middle = (left2+right2)>>1;                                //set new middle
      }
      right = middle;*/
      
      //TODO implement a binary search. 3, actually. One for a single index in the visible range, one for the left index, one for the right index
      
      int ind1=-2, ind2=-2;
      for(int i=0;i<=size();i++) {
        if(ind1==-2 && getX(i)+surfaceX>=0) { ind1=i-1; }
        if(ind1!=-2 && ind2==-2 && getX(i)+surfaceX>w) { ind2=i-1; }
      }
      if(ind1==-2) { return; } //temporary fix: if there's no text visible, then we just break out
      if(ind2==-2) { ind2=size(); }
      
      for(int i=ind1+1;i<ind2;i++) {
        graph.text(getText(i)+"",getX(i)+getX()+surfaceX-buffX,yTop); //display them TODO make sure this actually fucking works, delete me when you're done
      }
      
      if(ind1>=0) { //if there's clipped text on the left:
        //create an orphan box on the far left to display the clipped text
        Box special = new Box(getX(ind1)+surfaceX,ty+surfaceY,getW(ind1),getTextHeight()).setFill(0x00FFFFFF).setStroke(false).setText(new Text(getText(ind1)+"",0,0,tSize,tFill,LEFT,TOP));
        displayChild(special,graph,buffX,buffY); //use built-in display function to draw the clipped stuff
        //TODO make it so this can be done without calculating the outcodes. We already know what the outcodes are
      }
      
      if(ind2<size()) { //if there's clipped text on the right:
        //create an orphan box on the far right to display the clipped text
        Box special = new Box(getX(ind2)+surfaceX,ty+surfaceY,getW(ind2),getTextHeight()).setFill(0x00FFFFFF).setStroke(false).setText(new Text(getText(ind2)+"",0,0,tSize,tFill,LEFT,TOP));
        displayChild(special,graph,buffX,buffY); //use built-in display function to draw the clipped stuff
      }
    }
    
    if(this==mmio.typer && (System.currentTimeMillis()-blink & 512) ==0) { //if this is our selected textbox, and our cursor is in the correct cycle of blinking:
      drawCursor(graph, buffX, buffY); //draw the cursor
    }
  }
  
  public void drawCursor(PGraphics graph, float buffX, float buffY) {
    graph.stroke(cStroke); graph.strokeWeight(cThick); //set drawing parameters for cursor
    float xStart = getX(cursor)+surfaceX; //find x pos of cursor
    if(xStart>=w) { return; } //if it's too far right, we can't draw it
    
    if(!insert) { //if overtype, we draw cursor as underline
      float xEnd = (cursor==size() ? getX(cursor)+0.75f*tSize : getX(cursor+1))+surfaceX; //find x pos of right of cursor
      if(xEnd>0) { //if the cursor is even on screen:
        graph.line(max(xStart,0)+getX()-buffX,ty+getY()+surfaceY+getTextHeight()-buffY, min(xEnd,w)+getX()-buffX,ty+getY()+surfaceY+getTextHeight()-buffY); //draw it, with x constraints for clipping
      }
    }
    else if(xStart>0) { //otherwise, we draw cursor as vertical line (again, make sure it's on screen)
      graph.line(xStart+getX()-buffX, ty+getY()+surfaceY-buffY, xStart+getX()-buffX, ty+getY()+surfaceY+getTextHeight()-buffY);
    }
  }
  
  /////////////// TYPING (FUNDAMENTAL) //////////////////////
  
  public int size() { return texts.size(); } //number of characters in the text
  
  public float getX(int ind) {
    if(size()==0 && ind==0) { return tx; }
    if(ind==size()) { SimpleText s = texts.get(ind-1); return s.x+s.w; }
    return texts.get(ind).x;
  }
  
  public float getW(int ind) { return texts.get(ind).w; }
  public char getText(int ind) { return texts.get(ind).text; }
  
  public String getText() {
    String result = "";
    for(SimpleText txt : texts) { result+=txt; }
    return result;
  }
  
  //Each of the following editing functions return the change in width of the text. It can be positive or negative.
  
  public float insert(char text, int pos) { //types (using insert) a character into a certain position
    float w = mmio.getTextWidth(text+"",tSize); //get width of character
    texts.add(pos, new SimpleText(text, getX(pos), w)); //insert the character
    for(int n=pos+1;n<size();n++) { //loop through all characters after this one
      texts.get(n).x += w;          //shift their positions appropriately
    }
    return w;
  }
  
  public float overtype(char text, int pos) { //types (using overtype) a character into a certain position
    float w = mmio.getTextWidth(text+"",tSize); //get width of character
    if(pos==size()) { texts.add(new SimpleText(text, getX(pos), w)); } //if typing at the end, add it to the arraylist as a new entry
    else {                                                             //otherwise:
      float w2 = getW(pos);                               // find the width of the character we're replacing
      texts.set(pos, new SimpleText(text, getX(pos), w)); // replace the character
      for(int n=pos+1;n<size();n++) { //loop through all characters after this one
        texts.get(n).x += w-w2;       //shift their positions appropriately
      }
      return w-w2; //return the change in width
    }
    return w; //return the change in width
  }
  
  public float insert(String text, int pos) { //types (using insert) a string into a certain position
    texts.ensureCapacity(texts.size()+text.length()); //ensure capacity
    
    //first, insert all the characters of text, one by one
    float wTotal = 0; //total width of all characters
    for(int n=0;n<text.length();n++) { //loop through all characters in text
      float w = mmio.getTextWidth(text.charAt(n)+"",tSize);                  //calculate width of each character
      texts.add(pos+n, new SimpleText(text.charAt(n), getX(pos)+wTotal, w)); //insert each character
      wTotal+=w;                                                             //increment total width appropriately
    }
    
    //next, shift all characters after the text appropriately
    for(int n=pos+text.length();n<size();n++) { //loop through all characters after text
      texts.get(n).x += wTotal;                 //shift their positions appropriately
    }
    
    return wTotal; //return how much it changed by
  }
  
  public float remove(int pos) { //removes the character at pos
    if(pos<0 || pos>=size()) { return 0; } //out of range: do nothing, return 0
    
    float w = getW(pos);        //find width of character we're removing
    texts.remove(pos);          //remove said character
    for(int n=pos;n<size();n++) { //loop through all characters after the one we deleted
      texts.get(n).x -= w;        //shift their positions left by the width of that deleted string
    }
    return -w; //return how much it decreased by
  }
  
  public float remove(int pos1, int pos2) { //removes all characters from pos1 (inclusive) to pos2 (exclusive)
    //first, remove all the characters over the range, one by one
    float wTotal = getX(pos2)-getX(pos1); //total width of all removed characters (calculated before, not after)
    for(int n=pos1;n<pos2;n++) { //loop through all elements over the range
      texts.remove(pos1);        //repeatedly remove the first element in the range
    }
    
    for(int n=pos1;n<size();n++) { //loop through all elements after the ones we deleted
      texts.get(n).x -= wTotal;    //shift their positions left by the width of that deleted string
    }
    return -wTotal; //return how much it decreased by
  }
  
  public float clear() {
    float wTotal = getX(size())-tx; //first, calculate the width
    texts.clear(); //next, clear the texts
    return -wTotal; //finally, return the change
  }
  
  //////////////////// TYPING (PUBLIC) ////////////////////////////////////
  
  public void restrictCursor() { cursor = constrain(cursor,0,size()); }
  
  public void readInput(final InputCode inp, final boolean target) {
    final Textbox ref = this;
    final int[] ints = {0,1,2,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    String[] strings = new String[inp.strings.length]; arrayCopy(inp.strings, strings);
    char[] chars = new char[inp.chars.length]; arrayCopy(inp.chars, chars);
    int[] inst = inp.instructions;
    
    class IntGetter { public int get(int ind) { if(ind==-1) { return -1; } if(ind==-2) { return cursor; } if(ind==-3) { return ref.size(); } if(ind==-4) { return cursor==size()?0:texts.get(cursor).text; } return ints[ind]; } }
    IntGetter i = new IntGetter(); //this is so that we can still grab variables that wouldn't be accessible otherwise. Namely, cursor position, text length, char at cursor, and, just for convenience, -1
    
    for(int n=0;n<inp.instructions.length;) {
      switch(inst[n]) {
        case 'M': cursor = i.get(inst[n+1]);         n+=2; break; //move to position
        case 'S': cursor += inst[n+1];               n+=2; break; //shift by amount
        case 'I': insert(strings[inst[n+1]],cursor); n+=2; break; //insert string
        case 'i': insert(chars[inst[n+1]],cursor);   n+=2; break; //insert character
        case 'o': overtype(chars[inst[n+1]],cursor); n+=2; break; //overtype character
        
        case 'D': remove(cursor);      n++; break; //delete character
        case 'C': clear(); cursor = 0; n++; break; //clear
        
        case 'g': n=inst[n+1]; break; //GOTO line
        case 'G': n = (inst[n+1]==1) ? inst[n+2] : n+1; break; //if something == 1, GOTO line. Otherwise, go to next line
        
         //these last parts are just to make this whole shpiel Turing complete. Because might as well, right?
        case '=': ints[inst[n+1]]=inst[n+2]; n+=3; break; //assign variable to constant
        case '$': switch(inst[n+3]) {                     //assign variable to operation between 1-2 variables
          case '.': ints[inst[n+1]] = i.get(inst[n+2]);   n+=4; break; //one parameter operations (. = do nothing)
          case '!': ints[inst[n+1]] = i.get(inst[n+2])^1; n+=4; break;
          case '~': ints[inst[n+1]] = ~i.get(inst[n+2]);  n+=4; break;
          
          case '=': ints[inst[n+1]] = (i.get(inst[n+2])==i.get(inst[n+4])) ? 1 : 0; n+=5; break; //two parameter boolean operations
          case '<': ints[inst[n+1]] = (i.get(inst[n+2])< i.get(inst[n+4])) ? 1 : 0; n+=5; break;
          case '>': ints[inst[n+1]] = (i.get(inst[n+2])> i.get(inst[n+4])) ? 1 : 0; n+=5; break;
          
          case '+': ints[inst[n+1]] = i.get(inst[n+2]) + i.get(inst[n+4]); n+=5; break; //two parameter math operations
          case '-': ints[inst[n+1]] = i.get(inst[n+2]) - i.get(inst[n+4]); n+=5; break;
          case '*': ints[inst[n+1]] = i.get(inst[n+2]) * i.get(inst[n+4]); n+=5; break;
          case '/': ints[inst[n+1]] = i.get(inst[n+2]) / i.get(inst[n+4]); n+=5; break;
          case '%': ints[inst[n+1]] = i.get(inst[n+2]) % i.get(inst[n+4]); n+=5; break;
          case '&': ints[inst[n+1]] = i.get(inst[n+2]) & i.get(inst[n+4]); n+=5; break; //two parameter bitwise operations
          case '|': ints[inst[n+1]] = i.get(inst[n+2]) | i.get(inst[n+4]); n+=5; break;
          case '^': ints[inst[n+1]] = i.get(inst[n+2]) ^ i.get(inst[n+4]); n+=5; break;
        } break;
      }
    }
    restrictCursor(); //force cursor to be in bounds
    fixWidth();       //correct the width
    if(target) {      //if applicable:
      chooseTargetRecursive(getX(cursor),ty+0.5f*getTextHeight()); //adjust targeting system
      //chooseTargetRecursive(getX(cursor),ty,getX(cursor),ty+getTextHeight()); //TODO make this work
    }
    
    resetBlinker(); //text edit means we must make cursor visible
  }
  
  public void readInput(final InputCode inp) { readInput(inp, true); }
  
  public void readInput(int[] instruct) { readInput(new InputCode(instruct)); }
  public void readInput(int[] instruct, char[] charss) { readInput(new InputCode(instruct, charss)); }
  public void readInput(int[] instruct, String[] stringss) { readInput(new InputCode(instruct, stringss)); }
  public void readInput(int[] instruct, char[] charss, String[] stringss) { readInput(new InputCode(instruct, charss, stringss)); }
  
  public void fixWidth() { surfaceW = max(w, Mmio.xBuff+getX(size())); }
  
  ////////////// MISC /////////////////////
  
  public void resetBlinker() { blink = System.currentTimeMillis(); }
  
  static class CursorMover extends Box {
    Textbox buddy; //the parent cast to a textbox
    
    CursorMover(final Textbox t) {
      super(0,t.ty,t.w,t.getTextHeight());
      setFill(false).setStroke(false).setMobile(false).setParent(t);
      //setFill(0x80FF0000); //debug: gives the mover a redish hue to make it visible
      buddy = t;
    }
    
    public void release(Cursor curs) { //performs a release event, allowing the cursor to be moved by the mouse
      float sx = parent.getObjSurfaceX(); //get OBJECTIVE surface position
      boolean changed = false;            //record whether we actually changed (for debugging purposes)
      for(int n=0;n<=buddy.size();n++) {
        if((n==0 || sx+buddy.getX(n-1)+0.5f*buddy.getW(n-1)<curs.x) && (n==buddy.size() || sx+buddy.getX(n)+0.5f*buddy.getW(n)>curs.x)) {
          buddy.cursor = n; changed = true; break;
        }
      }
      buddy.releaseAction.act(); //perform the specified action
      
      if(!changed) { throw new RuntimeException("CURSOR FAILED TO SELECT"); }
      buddy.resetBlinker(); //make the cursor visible
    }
  }
}

static class SimpleText {
  char text; float x, w; byte properties=0; //the text displayed, position, width, misc properties
  
  SimpleText() { }
  SimpleText(char t, float x_, float w_) { text=t; x=x_; w=w_; }
  SimpleText(char t, float x_, float w_, byte p) { this(t,x_,w_); properties=p; }
  
  @Override public 
  String toString() { return text+""; }
}

static class InputCode {
  //cheat sheet: M=move cursor to i[$1], S=shift cursor by $1, I=insert string at s[$1] at cursor, i=insert char at c[$1] at cursor, o=overtype char at c[$1] at cursor,
  // D=delete char at cursor, C=clear text, g=goto $1, G=if i[$1]==1, GOTO $2, = = Assign i[$1]=$2, $=Assign i[$1]=i[$2] $3 [i[$4]], where $3 can be +-*/&|^% =<> ~!.
  
  String[] strings = new String[0];
  char[] chars = new char[0];
  
  int[] instructions;
  
  InputCode(int[] instruct) { instructions=instruct; }
  InputCode(int[] instruct, char[] charss) { instructions=instruct; chars=charss; }
  InputCode(int[] instruct, String[] stringss) { instructions=instruct; strings=stringss; }
  InputCode(int[] instruct, char[] charss, String[] stringss) { instructions=instruct; chars=charss; strings=stringss; }
  
  final static int[] LEFT  = {'S',-1}, RIGHT = {'S',1}, HOME = {'M',0}, END = {'M',-3}, DELETE = {'D'}, BACKSPACE = {'S',-1,'D'},
                     INSERT = {'i',0,'S',1}, OVERTYPE = {'o',0,'S',1}, CLEAR = {'C'};
}


  public void settings() { size(1080, 2130); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Calculator_5_App" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
